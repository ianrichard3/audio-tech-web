This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
.github/
  workflows/
    main.yml
public/
  vite.svg
scripts/
  verify-clerk-setup.sh
src/
  assets/
    cat.svg
    el-riche-mark.svg
  components/
    AuthScreen.vue
    ConnectionFinder.vue
    DevicesManager.vue
    PatchBayGrid.vue
  lib/
    api.ts
    authToken.ts
  store/
    index.ts
  ui/
    ConfirmDialog.vue
    strings.ts
    ToastHost.vue
  App.vue
  main.ts
  style.css
  vite-env.d.ts
.dockerignore
.env.example
.gitignore
CLERK_IMPLEMENTATION.md
docker-compose.yml
Dockerfile
front repomix-output.txt
IMPLEMENTATION_SUMMARY.md
index.html
package.json
README.md
TESTING_CLERK.md
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vite.config.ts

================================================================
Files
================================================================

================
File: scripts/verify-clerk-setup.sh
================
#!/bin/bash

# Script de validaci√≥n de configuraci√≥n de Clerk

echo "üîç Verificando configuraci√≥n de Clerk..."
echo ""

# Check if .env exists
if [ ! -f .env ]; then
    echo "‚ùå Archivo .env no encontrado"
    echo "   Copia .env.example a .env y configura las variables"
    exit 1
fi

# Check for Clerk key
if grep -q "VITE_CLERK_PUBLISHABLE_KEY=pk_" .env; then
    echo "‚úÖ VITE_CLERK_PUBLISHABLE_KEY configurada"
else
    echo "‚ùå VITE_CLERK_PUBLISHABLE_KEY no configurada o inv√°lida"
    echo "   Debe empezar con pk_test_ o pk_live_"
    exit 1
fi

# Check for API URL
if grep -q "VITE_API_URL=" .env; then
    echo "‚úÖ VITE_API_URL configurada"
else
    echo "‚ö†Ô∏è  VITE_API_URL no configurada (usar√° http://localhost:8088 por defecto)"
fi

# Check if @clerk/vue is installed
if [ -d "node_modules/@clerk/vue" ]; then
    echo "‚úÖ @clerk/vue instalado"
else
    echo "‚ùå @clerk/vue no instalado"
    echo "   Ejecuta: npm install"
    exit 1
fi

echo ""
echo "‚ú® Configuraci√≥n v√°lida!"
echo ""
echo "Pr√≥ximos pasos:"
echo "  1. npm run dev"
echo "  2. Abrir http://localhost:5173"
echo "  3. Probar login con Google"
echo ""
echo "Ver TESTING_CLERK.md para plan de pruebas completo"

================
File: src/components/AuthScreen.vue
================
<script setup lang="ts">
import { SignIn } from '@clerk/vue'
import logoUrl from '../assets/el-riche-mark.svg'
import { strings } from '../ui/strings'

const t = strings
</script>

<template>
  <div class="auth-screen">
    <div class="auth-container">
      <div class="auth-header">
        <img class="auth-logo" :src="logoUrl" alt="" />
        <h1 class="auth-title">{{ t.app.name }}</h1>
        <p class="auth-subtitle">{{ t.app.tagline }}</p>
      </div>
      
      <div class="auth-content">
        <p class="auth-prompt">Inici√° sesi√≥n para acceder a la aplicaci√≥n</p>
        <SignIn />
      </div>
    </div>
  </div>
</template>

<style scoped>
.auth-screen {
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 100vh;
  background: linear-gradient(135deg, #1a1a2e 0%, #0f0f1e 100%);
  padding: var(--space-4);
}

.auth-container {
  width: 100%;
  max-width: 420px;
  text-align: center;
}

.auth-header {
  margin-bottom: var(--space-6);
}

.auth-logo {
  width: 80px;
  height: 80px;
  margin-bottom: var(--space-4);
  filter: drop-shadow(0 4px 12px rgba(99, 102, 241, 0.3));
}

.auth-title {
  font-size: 2rem;
  font-weight: 700;
  color: var(--c-primary, #6366f1);
  margin: 0 0 var(--space-2) 0;
}

.auth-subtitle {
  font-size: 0.95rem;
  color: rgba(255, 255, 255, 0.6);
  margin: 0;
}

.auth-content {
  background: rgba(255, 255, 255, 0.05);
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 12px;
  padding: var(--space-6);
  backdrop-filter: blur(10px);
}

.auth-prompt {
  font-size: 0.95rem;
  color: rgba(255, 255, 255, 0.8);
  margin: 0 0 var(--space-5) 0;
}
</style>

================
File: src/lib/authToken.ts
================
// Token provider para conectar Clerk con la capa de API
// Este m√≥dulo permite que api.ts acceda al token sin depender directamente de useAuth()

type GetTokenFn = (options?: { skipCache?: boolean }) => Promise<string | null>

let tokenGetter: GetTokenFn | null = null

/**
 * Registra la funci√≥n getToken de Clerk.
 * Debe ser llamada desde un componente Vue con acceso a useAuth()
 */
export function registerTokenGetter(getter: GetTokenFn): void {
  tokenGetter = getter
}

/**
 * Obtiene el token actual.
 * @param skipCache - Si true, fuerza refresh del token (√∫til para reintentos 401)
 * @returns El token JWT o null si no hay sesi√≥n
 */
export async function getAuthToken(options?: { skipCache?: boolean }): Promise<string | null> {
  if (!tokenGetter) {
    console.error('[authToken] Token getter not registered. Did you call registerTokenGetter in App.vue?')
    return null
  }
  
  try {
    return await tokenGetter(options)
  } catch (error) {
    console.error('[authToken] Failed to get token:', error)
    return null
  }
}

/**
 * Verifica si el token provider est√° inicializado
 */
export function isTokenProviderReady(): boolean {
  return tokenGetter !== null
}

================
File: CLERK_IMPLEMENTATION.md
================
# Integraci√≥n de Clerk Auth - Implementaci√≥n Completada

## ‚úÖ Cambios realizados

### 1. Dependencias instaladas
- `@clerk/vue` - SDK oficial de Clerk para Vue 3

### 2. Variables de entorno
- `.env` ya contiene `VITE_CLERK_PUBLISHABLE_KEY`
- Creado `.env.example` como referencia

### 3. Inicializaci√≥n de Clerk
**Archivo modificado:** `src/main.ts`
- Importa y registra `clerkPlugin`
- Valida que la env var est√© presente
- Muestra error claro si falta la configuraci√≥n

### 4. Gesti√≥n de tokens
**Archivo nuevo:** `src/lib/authToken.ts`
- M√≥dulo centralizado para acceso al token
- Funci√≥n `registerTokenGetter()` para conectar Clerk con la API
- Funci√≥n `getAuthToken()` que la capa API usa para obtener tokens

### 5. Capa de API actualizada
**Archivo modificado:** `src/lib/api.ts`
- Importa `getAuthToken` desde authToken.ts
- Inyecta header `Authorization: Bearer <token>` en todas las requests
- Implementa retry autom√°tico en caso de 401 (token expirado)
- Lanza errores espec√≠ficos para AUTH_EXPIRED y AUTH_FORBIDDEN

### 6. Store actualizado
**Archivo modificado:** `src/store/index.ts`
- Agregado flag `hasLoadedInitialData` para evitar cargas m√∫ltiples
- Manejo de errores AUTH_EXPIRED y AUTH_FORBIDDEN con mensajes apropiados
- No hace requests hasta que el usuario est√© autenticado

### 7. Strings de UI
**Archivo modificado:** `src/ui/strings.ts`
- Agregados mensajes de error:
  - `sessionExpired`: "Sesi√≥n expirada. Por favor, volv√© a iniciar sesi√≥n."
  - `noPermission`: "No ten√©s permisos para acceder a estos datos."

### 8. Pantalla de autenticaci√≥n
**Archivo nuevo:** `src/components/AuthScreen.vue`
- Componente dedicado para login/signup
- Usa `<SignIn>` de Clerk
- Dise√±o consistente con la app principal
- Branding con logo y nombre de la app

### 9. App.vue refactorizado
**Archivo modificado:** `src/App.vue`
- Envuelve la UI con `<SignedIn>` y `<SignedOut>`
- Muestra AuthScreen cuando el usuario no est√° autenticado
- Muestra loader mientras Clerk inicializa (`!isLoaded`)
- Registra `getToken` usando `watchEffect` cuando el usuario se loguea
- Carga datos autom√°ticamente cuando `isLoaded && isSignedIn` (una sola vez)
- Agregado `UserButton` en el header para logout y gesti√≥n de cuenta
- Estilos responsive actualizados para el nuevo layout

## üéØ Criterios de "done" cumplidos

‚úÖ El usuario puede:
- Ver pantalla de Sign In / Sign Up (Clerk)
- Loguearse con Google (configurado en Clerk Dashboard)
- Ver la UI existente tras autenticarse
- Hacer llamadas a la API con `Authorization: Bearer <token>`
- Cerrar sesi√≥n desde UserButton

‚úÖ El frontend:
- No hace requests si el usuario no est√° autenticado
- Maneja correctamente estados de carga
- Maneja 401/403 con UX apropiada
- No guarda tokens manualmente (usa Clerk)

## üß™ Pruebas sugeridas

### 1. Auth flow b√°sico
```bash
npm run dev
```

1. Abrir en modo inc√≥gnito: debe verse AuthScreen (no la app)
2. Network tab: confirmar que NO hay requests a `/state`
3. Iniciar sesi√≥n con Google
4. Debe verse la app completa
5. Network tab: confirmar request a `/state` con header `Authorization: Bearer ...`

### 2. Token en requests
1. Abrir DevTools ‚Üí Network
2. Realizar cualquier acci√≥n (crear device, link port, etc.)
3. Verificar que todas las requests tengan `Authorization: Bearer ...`

### 3. Logout
1. Click en UserButton (arriba a la derecha)
2. Click en "Sign out"
3. Debe volver a AuthScreen
4. Network: no debe haber requests a la API

### 4. Manejo de 401
Para testear, pod√©s:
- Configurar tu backend para devolver 401
- O usar DevTools para bloquear/modificar requests
- La app debe reintentar una vez y mostrar mensaje apropiado

## üìù Pr√≥ximos pasos (opcional)

### Workspace/Organizations (multi-tenant)
Si quer√©s soportar m√∫ltiples studios/workspaces:

1. **Habilitar Organizations en Clerk Dashboard**
2. **Agregar selector de org en la UI:**
   ```vue
   import { OrganizationSwitcher } from '@clerk/vue'
   ```
3. **Enviar workspace ID al backend:**
   - En `api.ts`, agregar header: `X-Workspace-Id: <orgId>`
   - O pasar como query param seg√∫n tu dise√±o backend
4. **Actualizar store para mantener org activa**

### Mejorar UX de errores
- Agregar modal/banner para 401 con bot√≥n "Volver a iniciar sesi√≥n"
- Toast persistente para 403
- Retry button para errores de red

### Preparar para producci√≥n
1. Obtener Clerk production keys
2. Setear `VITE_CLERK_PUBLISHABLE_KEY` en tu plataforma de deploy
3. Verificar CORS entre frontend y backend en prod
4. Testear el flujo completo en staging

## üîê Seguridad

- Los tokens JWT se manejan autom√°ticamente por Clerk
- No se guardan en localStorage manualmente
- El token se regenera y rota autom√°ticamente
- En producci√≥n, asegurate de que tu backend valide los tokens con la Clerk API

## üìö Referencias

- [Clerk Vue Docs](https://clerk.com/docs/quickstarts/vue)
- [Clerk Organizations](https://clerk.com/docs/organizations/overview)
- [Clerk Authentication](https://clerk.com/docs/authentication/overview)

================
File: front repomix-output.txt
================
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)


================================================================
Directory Structure
================================================================
.github/
  workflows/
    main.yml
public/
  vite.svg
src/
  assets/
    cat.svg
    el-riche-mark.svg
  components/
    ConnectionFinder.vue
    DevicesManager.vue
    PatchBayGrid.vue
  lib/
    api.ts
  store/
    index.ts
  ui/
    ConfirmDialog.vue
    strings.ts
    ToastHost.vue
  App.vue
  main.ts
  style.css
  vite-env.d.ts
.dockerignore
.env.example
.gitignore
docker-compose.yml
Dockerfile
index.html
package.json
README.md
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vite.config.ts

================================================================
Files
================================================================

================
File: public/vite.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>

================
File: src/assets/cat.svg
================
<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg height="800px" width="800px" version="1.1" id="_x32_" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" 
	 viewBox="0 0 512 512"  xml:space="preserve">
<style type="text/css">
	.st0{fill:#000000;}
</style>
<g>
	<path class="st0" d="M504.302,195.59c-10.618-6.362-29.71-43.514-33.959-47.755c-4.249-4.256-28.662-13.81-28.662-13.81
		l-13.795-43.514c-26.542,3.185-42.449,45.634-43.513,48.819c0,0-2.661,73.764-120.47,45.11
		c-84.437-20.54-135.22-40.407-177.872-0.36c-2.668-4.578-4.491-9.234-5.822-14.257c-2.378-9.062-2.918-19.46-2.91-31.308
		c0-5.806,0.109-11.924,0.117-18.34c-0.008-13.436-0.493-28.248-4.046-44.015C69.85,60.386,63.136,43.743,51.344,27.162
		c-5.086-7.168-15.024-8.858-22.199-3.764c-7.167,5.094-8.858,15.031-3.764,22.199c9.304,13.145,14.162,25.368,16.932,37.551
		c2.739,12.167,3.271,24.397,3.264,37.027c0,6.024-0.118,12.136-0.118,18.34c0.016,12.646,0.438,25.799,3.928,39.32
		c2.746,10.735,7.722,21.58,15.508,31.706C31.93,261.458,50.037,316.584,50.037,316.584l-34.093,54.241
		c-0.618,0.978-1.033,2.066-1.244,3.192L0.146,454.073c-0.641,3.521,0.862,7.08,3.819,9.084l40.979,27.763
		c0.876,0.602,1.964,0.775,2.981,0.493c1.026-0.274,1.863-0.994,2.308-1.949l8.326-17.825c0.618-1.338,0.368-2.918-0.634-3.998
		l-10.728-11.448c-2.182-2.324-2.973-5.634-2.081-8.701l17.84-61.033c0.579-1.948,1.784-3.646,3.435-4.82l23.983-17.058
		c3.255-2.332,7.66-2.222,10.806,0.251c3.146,2.472,4.288,6.721,2.809,10.438L93.41,401.858c-1.22,3.051-0.681,6.525,1.401,9.06
		l60.298,73.365h45.218c1.996,0,3.616-1.62,3.616-3.607v-22.504c0-1.996-1.62-3.615-3.616-3.615h-14.303
		c-3.342,0-6.409-1.854-7.982-4.804l-24.484-41.049c-1.643-3.106-1.33-6.87,0.783-9.663l21.948-28.999
		c1.706-2.245,4.367-3.575,7.192-3.575h61.197c2.872,0,5.579,1.376,7.277,3.701c1.698,2.324,2.191,5.313,1.33,8.059l-19.726,62.16
		c-0.626,1.957-0.564,4.077,0.18,5.994l12.653,32.598h39.272v-8.49l-6.494-20.415c-0.61-1.909-0.563-3.967,0.133-5.852
		l26.471-71.847c1.315-3.553,4.694-5.908,8.474-5.908h27.011c2.449,0,4.796,1.002,6.502,2.777l74.813,103.365c0,0,38.208,0,50.947,0
		c12.738,0,7.809-25.414-4.241-26.542c-22.826-2.12-52.004-65.798-64.742-88.09c-12.739-22.285,24.664-91.299,53.067-94.453
		c28.654-3.185,43.514-14.867,47.763-30.79C513.856,223.187,514.92,201.959,504.302,195.59z"/>
</g>
</svg>

================
File: src/assets/el-riche-mark.svg
================
<svg width="120" height="120" viewBox="0 0 120 120" fill="none" xmlns="http://www.w3.org/2000/svg">
  <rect x="8" y="8" width="104" height="104" rx="20" stroke="#8FC09B" stroke-width="6" />
  <circle cx="60" cy="60" r="26" stroke="#8FC09B" stroke-width="6" />
  <path d="M34 36H86" stroke="#8FC09B" stroke-width="6" stroke-linecap="round" />
  <path d="M34 84H86" stroke="#8FC09B" stroke-width="6" stroke-linecap="round" />
</svg>

================
File: src/ui/ConfirmDialog.vue
================
<script setup lang="ts">
import { strings } from './strings'

const t = strings

defineProps<{ title: string; message: string; confirmLabel?: string; cancelLabel?: string }>()

defineEmits<{ confirm: []; cancel: [] }>()
</script>

<template>
  <div class="confirm-overlay" role="dialog" aria-modal="true">
    <div class="confirm-card">
      <h3>{{ title }}</h3>
      <p>{{ message }}</p>
      <div class="confirm-actions">
        <button class="btn ghost" @click="$emit('cancel')">
          {{ cancelLabel || t.confirm.cancel }}
        </button>
        <button class="btn solid" @click="$emit('confirm')">
          {{ confirmLabel || t.confirm.confirm }}
        </button>
      </div>
    </div>
  </div>
</template>

<style scoped>
.confirm-overlay {
  position: fixed;
  inset: 0;
  background: rgba(9, 8, 6, 0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2500;
}

.confirm-card {
  background: var(--surface-2);
  border: 1px solid var(--border-default);
  border-radius: var(--radius-3);
  padding: var(--space-5);
  max-width: 360px;
  width: calc(100% - 40px);
  box-shadow: var(--shadow-2);
}

.confirm-card h3 {
  margin: 0 0 var(--space-2);
  font-size: 1.4rem;
}

.confirm-card p {
  margin: 0 0 var(--space-4);
  color: var(--text-secondary);
}

.confirm-actions {
  display: flex;
  justify-content: flex-end;
  gap: var(--space-2);
}

.btn {
  border-radius: var(--radius-2);
  border: 1px solid transparent;
  padding: 8px 14px;
  font-weight: 600;
  cursor: pointer;
}

.btn.ghost {
  background: transparent;
  border-color: var(--border-default);
  color: var(--text-secondary);
}

.btn.solid {
  background: var(--accent);
  color: #0d0f0c;
}
</style>

================
File: src/ui/strings.ts
================
export const strings = {
  app: {
    name: 'El Riche Patchbay',
    tagline: 'Studio patchbay control',
    loadingData: 'Loading data...',
    retry: 'Retry',
    syncing: 'Syncing...',
    synced: 'Synced',
    syncIssue: 'Sync issue',
    export: 'Export',
    help: 'Help',
    shortcuts: 'Shortcuts',
    comingSoon: 'Coming soon',
    dismiss: 'Dismiss',
    closeSymbol: 'x',
  },
  nav: {
    patchbay: 'Patchbay',
    devices: 'Devices',
    connections: 'Connections',
  },
  confirm: {
    confirm: 'Confirm',
    cancel: 'Cancel',
    overwriteTitle: 'Overwrite patch point?',
    overwriteMessage: (deviceName: string, portLabel: string) =>
      `This slot is already connected to ${deviceName} - ${portLabel}. Overwrite it?`,
    deleteDeviceTitle: 'Delete device?',
    deleteDeviceMessage: (deviceName: string) =>
      `Delete ${deviceName}? This cannot be undone.`,
  },
  toast: {
    linkedSuccess: (deviceName: string, portLabel: string, patchbayId: number) =>
      `Linked ${deviceName} ${portLabel} -> Patch #${patchbayId}.`,
    linkFailed: 'Linking failed. Please try again.',
    unlinkFailed: 'Unlink failed. Please try again.',
    loadFailed: 'Failed to load data. Please retry.',
    deviceSaved: 'Device saved.',
    deviceDeleted: 'Device deleted.',
    deviceSaveFailed: 'Failed to save device.',
    deviceDeleteFailed: 'Failed to delete device.',
    imageParseFailed: 'Image parsing failed. Try a clearer, well-lit photo.',
  },
  patchbay: {
    linkingBanner: (deviceName: string, portLabel: string) =>
      `Select a patch point for: ${deviceName} - ${portLabel}.`,
    linkingFallback: 'Select a patch point to link.',
    cancel: 'Cancel',
    showingConnection: (left: number, right: number) =>
      `Showing connection: #${left} <-> #${right}`,
    clearHighlights: 'Clear',
    searchPlaceholder: 'Search patchbay (point or device)...',
    patchPointTitle: (id: number) => `Patch Point #${id}`,
    nameLabel: 'Name',
    descriptionLabel: 'Description',
    typeLabel: 'Type',
    connectionLabel: 'Connection',
    connectedTo: 'Connected to',
    portLabel: 'Port',
    unlink: 'Unlink',
    notConnected: 'Not connected',
    linkDevice: 'Link device',
    close: 'Close',
    linkDeviceTitle: (id: number) => `Link device to point #${id}`,
    searchDevicesPlaceholder: 'Search devices...',
    occupiedTag: (id: number) => `(#${id})`,
    tooltip: (deviceName: string, portLabel: string) => `${deviceName} - ${portLabel}`,
    legendTitle: 'Legend',
    legendLinked: 'Linked',
    legendOpen: 'Open',
    legendMatch: 'Search match',
    legendHighlight: 'Highlighted',
    rowLabels: ['A', 'B'],
    rowLabel: (label: string) => `Row ${label}`,
    columnLabel: (label: number) => `Col ${label}`,
    linkDeviceAction: 'Link to device',
  },
  devices: {
    title: 'Devices',
    searchPlaceholder: 'Search devices...',
    addDevice: 'Add Device',
    portsCount: (count: number) => `${count} Ports`,
    typeLabel: 'Type',
    idLabel: 'ID',
    portsConfig: 'Ports Configuration',
    linkedTo: (patchbayId: number) => `Linked to #${patchbayId}`,
    goToPatch: (patchbayId: number) => `Go to patch #${patchbayId}`,
    unlink: 'Unlink',
    notConnected: 'Not connected',
    link: 'Link',
    deleteDevice: 'Delete Device',
    closeDetail: 'Close',
    editDevice: 'Edit Device',
    addNewDevice: 'Add New Device',
    tabManual: 'Manual',
    tabAutoDetect: 'Auto-detect',
    nameLabel: 'Name',
    namePlaceholder: 'Device name',
    typePlaceholder: 'Select type',
    portsLabel: 'Ports',
    addPort: '+ Add Port',
    portNamePlaceholder: 'Port name',
    removePort: 'Remove',
    noPorts: 'No ports added yet.',
    resetForm: 'Reset Form',
    updateDevice: 'Update Device',
    createDevice: 'Create Device',
    aiHelp: 'Upload a device photo; we will detect ports and create a draft.',
    aiUpload: 'Upload or take photo',
    aiProcessing: 'Analyzing image...',
    aiDraftReady: 'Draft ready. Review and edit before saving.',
    aiReviewDraft: 'Review draft',
    aiSteps: {
      upload: '1 Upload',
      processing: '2 Processing',
      review: '3 Review',
    },
    addPortLabel: (index: number) => `Port ${index}`,
    validation: {
      addPortFirst: 'Add at least one port.',
      nameRequired: 'Device name is required.',
    },
    saving: 'Saving...',
    portTypes: {
      Input: 'Input',
      Output: 'Output',
      Other: 'Other',
    },
    deviceTypes: ['Preamp', 'Compressor', 'EQ', 'Interface', 'Console', 'Other'],
  },
  connections: {
    title: 'Connection Finder',
    subtitle: 'Select two device ports to see which patch points to cable.',
    origin: 'Origin',
    destination: 'Destination',
    sideALabel: 'A',
    sideBLabel: 'B',
    searchPlaceholder: 'Search device or port...',
    unlinked: 'Unlinked',
    noResults: 'No results found',
    patchbayLabel: 'Patchbay',
    notLinkedWarning: 'Not linked to patchbay',
    swapTitle: 'Swap',
    clearSelection: 'Clear selection',
    swapLabel: 'Swap',
    resultSuccessTitle: 'Connection found',
    resultErrorTitle: 'Cannot connect',
    successBadge: 'OK',
    errorBadge: 'NO',
    cableLabel: 'Cable',
    resultInstruction: (a: number, b: number) =>
      `Connect patch #${a} (source) to patch #${b} (destination).`,
    goToPatchbay: 'View highlighted patch points',
    linkNow: 'Link this port now',
    linkNowFor: (label: string) => `Link ${label}`,
    copyInstruction: 'Copy instruction',
    copySuccess: 'Instruction copied.',
    copyFailed: 'Copy failed. Please try again.',
    linkReturnHint: 'Port linked. Continue to get patch instructions.',
    linkRequiredTitle: 'Link required',
    linkRequiredHint: 'Map the missing port to a patch point to get the instruction.',
    pickPatchPoint: 'Select patch point',
    mapPort: 'Map port',
    patchPointOption: (id: number, name: string) => `#${id} - ${name}`,
    hint: 'Link ports to patch points from the Devices tab first.',
    emptyTitle: 'Pick a source and destination port to see the cable path.',
    emptyIcon: '...',
    errorBothUnlinked: 'Neither port is linked to the patchbay.',
    errorUnlinked: (label: string) => `${label} is not linked to the patchbay.`,
  },
}

export type Strings = typeof strings

================
File: src/ui/ToastHost.vue
================
<script setup lang="ts">
import { store } from '../store'
import { strings } from './strings'

const t = strings

const dismiss = (id: string) => {
  store.dismissToast(id)
}
</script>

<template>
  <div class="toast-host" aria-live="polite">
    <div
      v-for="toast in store.toasts"
      :key="toast.id"
      class="toast"
      :class="`toast-${toast.type}`"
      role="status"
    >
      <div class="toast-message">{{ toast.message }}</div>
      <button class="toast-close" :aria-label="t.app.dismiss" @click="dismiss(toast.id)">
        {{ t.app.closeSymbol }}
      </button>
    </div>
  </div>
</template>

<style scoped>
.toast-host {
  position: fixed;
  top: var(--space-6);
  right: var(--space-6);
  display: flex;
  flex-direction: column;
  gap: var(--space-3);
  z-index: 3000;
}

.toast {
  min-width: 240px;
  max-width: 320px;
  background: var(--surface-2);
  color: var(--text-primary);
  border-radius: var(--radius-3);
  border: 1px solid var(--border-default);
  padding: var(--space-3) var(--space-3);
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  gap: var(--space-2);
  box-shadow: var(--shadow-1);
  animation: toast-in 0.25s ease-out;
}

.toast-message {
  font-size: 0.95rem;
  line-height: 1.4;
}

.toast-close {
  background: transparent;
  border: none;
  color: var(--text-muted);
  cursor: pointer;
  font-size: 1.1rem;
  line-height: 1;
  padding: 0;
}

.toast-success {
  border-color: rgba(106, 163, 111, 0.7);
}

.toast-error {
  border-color: rgba(176, 75, 61, 0.7);
}

.toast-info {
  border-color: rgba(143, 192, 155, 0.6);
}

@keyframes toast-in {
  from {
    opacity: 0;
    transform: translateY(-6px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@media (max-width: 720px) {
  .toast-host {
    right: var(--space-4);
    left: var(--space-4);
  }

  .toast {
    max-width: none;
  }
}
</style>

================
File: .dockerignore
================
.git
node_modules
.gitignore
Dockerfile
.github
*.log

================
File: .env.example
================
VITE_API_URL=http://localhost:8088

================
File: tsconfig.json
================
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}

================
File: src/main.ts
================
import { createApp } from 'vue'
import './style.css'
import App from './App.vue'

createApp(App).mount('#app')

================
File: .gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Environment variables
.env
.env.local
.env.*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

================
File: tsconfig.node.json
================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "types": ["node"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}

================
File: vite.config.ts
================
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { fileURLToPath, URL } from 'node:url'

// https://vite.dev/config/
export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: {
      '@': fileURLToPath(new URL('./src', import.meta.url))
    }
  }
})

================
File: src/components/ConnectionFinder.vue
================
<script setup lang="ts">
import { ref, computed, watch } from 'vue'
import { store, type Device, type DevicePort } from '../store'
import { strings } from '../ui/strings'

const t = strings

interface PortSelection {
  device: Device | null
  port: DevicePort | null
}

interface MissingSelection {
  side: 'a' | 'b'
  selection: PortSelection
}

interface ConnectionResultSuccess {
  type: 'success'
  patchA: number
  patchB: number
  deviceA?: string
  portA?: string
  deviceB?: string
  portB?: string
}

interface ConnectionResultError {
  type: 'error'
  message: string
  missing: MissingSelection[]
}

const searchA = ref('')
const searchB = ref('')
const showDropdownA = ref(false)
const showDropdownB = ref(false)
const showReturnHint = ref(false)

const mappingChoice = ref<{ a: number | null; b: number | null }>({ a: null, b: null })

const allPorts = computed(() => {
  const result: { device: Device; port: DevicePort }[] = []
  for (const device of store.devices) {
    for (const port of device.ports) {
      result.push({ device, port })
    }
  }
  return result
})

const filteredPortsA = computed(() => {
  if (!searchA.value) return allPorts.value
  const query = searchA.value.toLowerCase()
  return allPorts.value.filter(item =>
    item.device.name.toLowerCase().includes(query) ||
    item.port.label.toLowerCase().includes(query)
  )
})

const filteredPortsB = computed(() => {
  if (!searchB.value) return allPorts.value
  const query = searchB.value.toLowerCase()
  return allPorts.value.filter(item =>
    item.device.name.toLowerCase().includes(query) ||
    item.port.label.toLowerCase().includes(query)
  )
})

const availablePatchPoints = computed(() => {
  return store.patchbayNodes.filter(node => !store.getDeviceByPatchbayId(node.id))
})

const getSelection = (side: 'a' | 'b'): PortSelection => {
  const state = store.connectionFinderState[side]
  if (!state) return { device: null, port: null }
  const device = store.devices.find(item => item.id === state.deviceId) || null
  if (!device) return { device: null, port: null }
  const port = device.ports.find(item => item.id === state.portId) || null
  if (!port) return { device: null, port: null }
  return { device, port }
}

const selectionA = computed(() => getSelection('a'))
const selectionB = computed(() => getSelection('b'))

const selectPortA = (device: Device, port: DevicePort) => {
  store.setConnectionFinderSelection('a', device.id, port.id)
  showDropdownA.value = false
}

const selectPortB = (device: Device, port: DevicePort) => {
  store.setConnectionFinderSelection('b', device.id, port.id)
  showDropdownB.value = false
}

const clearSelectionA = () => {
  store.clearConnectionFinderSelection('a')
  searchA.value = ''
}

const clearSelectionB = () => {
  store.clearConnectionFinderSelection('b')
  searchB.value = ''
}

watch(selectionA, (value) => {
  if (value.port && value.device) {
    searchA.value = `${value.device.name} - ${value.port.label}`
    mappingChoice.value.a = null
  }
})

watch(selectionB, (value) => {
  if (value.port && value.device) {
    searchB.value = `${value.device.name} - ${value.port.label}`
    mappingChoice.value.b = null
  }
})

const connectionResult = computed<ConnectionResultSuccess | ConnectionResultError | null>(() => {
  const portA = selectionA.value.port
  const portB = selectionB.value.port

  if (!portA || !portB) return null

  const patchA = portA.patchbayId
  const patchB = portB.patchbayId
  const missing: MissingSelection[] = []

  if (!patchA) missing.push({ side: 'a', selection: selectionA.value })
  if (!patchB) missing.push({ side: 'b', selection: selectionB.value })

  if (!patchA && !patchB) {
    return {
      type: 'error',
      message: t.connections.errorBothUnlinked,
      missing,
    }
  }

  if (!patchA) {
    return {
      type: 'error',
      message: t.connections.errorUnlinked(`${selectionA.value.device?.name} - ${portA.label}`),
      missing,
    }
  }

  if (!patchB) {
    return {
      type: 'error',
      message: t.connections.errorUnlinked(`${selectionB.value.device?.name} - ${portB.label}`),
      missing,
    }
  }

  return {
    type: 'success',
    patchA,
    patchB,
    deviceA: selectionA.value.device?.name,
    portA: portA.label,
    deviceB: selectionB.value.device?.name,
    portB: portB.label,
  }
})

const highlightedPatches = computed((): number[] => {
  if (connectionResult.value?.type === 'success') {
    return [connectionResult.value.patchA, connectionResult.value.patchB]
  }
  return []
})

watch(highlightedPatches, (newVal) => {
  store.highlightedPatchIds = newVal
}, { immediate: true })

watch(() => store.activeTab, (tab) => {
  if (tab !== 'connections') return
  const payload = store.lastLinkReturnPayload as { resume?: string; missingSide?: 'a' | 'b' } | null
  if (!payload || payload.resume !== 'connections') return
  showReturnHint.value = true
  store.clearLinkReturnPayload()
})

const dismissReturnHint = () => {
  showReturnHint.value = false
}

const goToPatchbay = () => {
  const focusId = highlightedPatches.value[0]
  store.patchbayFocusId = focusId || null
  store.setTab('patchbay')
}

const swapSelections = () => {
  store.swapConnectionFinderSelections()
}

const linkNow = (missing: MissingSelection) => {
  if (!missing.selection.device || !missing.selection.port) return
  store.startLinkingPort({
    portId: missing.selection.port.id,
    deviceId: missing.selection.device.id,
    deviceName: missing.selection.device.name,
    portLabel: missing.selection.port.label,
  }, {
    returnTab: 'connections',
    returnPayload: { resume: 'connections', missingSide: missing.side },
  })
}

const mapMissingPort = async (missing: MissingSelection) => {
  const patchbayId = mappingChoice.value[missing.side]
  if (!patchbayId) return
  if (!missing.selection.device || !missing.selection.port) return
  try {
    const didLink = await store.linkPatchbayToDevice(
      patchbayId,
      missing.selection.device.id,
      missing.selection.port.id
    )
    if (!didLink) return
    store.pushToast({
      type: 'success',
      message: strings.toast.linkedSuccess(
        missing.selection.device.name,
        missing.selection.port.label,
        patchbayId
      ),
    })
    mappingChoice.value[missing.side] = null
  } catch (err: any) {
    store.pushToast({ type: 'error', message: err?.message || strings.toast.linkFailed })
  }
}

const copyInstruction = async () => {
  if (!connectionResult.value || connectionResult.value.type !== 'success') return
  const text = t.connections.resultInstruction(connectionResult.value.patchA, connectionResult.value.patchB)
  try {
    await navigator.clipboard.writeText(text)
    store.pushToast({ type: 'success', message: t.connections.copySuccess })
  } catch (err) {
    store.pushToast({ type: 'error', message: t.connections.copyFailed })
  }
}
</script>

<template>
  <div class="connection-finder">
    <div class="finder-header">
      <h2>{{ t.connections.title }}</h2>
      <p class="subtitle">{{ t.connections.subtitle }}</p>
    </div>

    <div v-if="showReturnHint" class="return-hint">
      <span>{{ t.connections.linkReturnHint }}</span>
      <button class="ghost-btn" @click="dismissReturnHint">{{ t.app.dismiss }}</button>
    </div>

    <div class="finder-body">
      <div class="selectors-container">
        <div class="selector-box">
          <label class="selector-label">
            <span class="label-icon">{{ t.connections.sideALabel }}</span>
            {{ t.connections.origin }}
          </label>
          <div class="search-wrapper">
            <input
              v-model="searchA"
              @focus="showDropdownA = true"
              @input="showDropdownA = true; store.clearConnectionFinderSelection('a')"
              :placeholder="t.connections.searchPlaceholder"
              class="search-input"
            />
            <button
              v-if="selectionA.port"
              class="clear-btn"
              :aria-label="t.connections.clearSelection"
              @click="clearSelectionA"
            >
              {{ t.app.closeSymbol }}
            </button>
          </div>

          <div v-if="showDropdownA && !selectionA.port" class="dropdown">
            <div
              v-for="item in filteredPortsA"
              :key="`${item.device.id}-${item.port.id}`"
              class="dropdown-item"
              @click="selectPortA(item.device, item.port)"
            >
              <span class="device-name">{{ item.device.name }}</span>
              <span class="port-info">
                <span class="port-label">{{ item.port.label }}</span>
                <span class="port-type" :class="item.port.type.toLowerCase()">
                  {{ t.devices.portTypes[item.port.type] }}
                </span>
                <span v-if="item.port.patchbayId" class="patch-id">#{{ item.port.patchbayId }}</span>
                <span v-else class="not-linked">{{ t.connections.unlinked }}</span>
              </span>
            </div>
            <div v-if="filteredPortsA.length === 0" class="no-results">
              {{ t.connections.noResults }}
            </div>
          </div>

          <div v-if="selectionA.port" class="selection-info">
            <div class="selected-device">{{ selectionA.device?.name }}</div>
            <div class="selected-port">
              {{ selectionA.port.label }}
              <span class="port-type" :class="selectionA.port.type.toLowerCase()">
                {{ t.devices.portTypes[selectionA.port.type] }}
              </span>
            </div>
            <div v-if="selectionA.port.patchbayId" class="patch-number">
              {{ t.connections.patchbayLabel }}: <strong>#{{ selectionA.port.patchbayId }}</strong>
            </div>
            <div v-else class="not-linked-warning">{{ t.connections.notLinkedWarning }}</div>
          </div>
        </div>

        <button class="swap-btn" :title="t.connections.swapTitle" @click="swapSelections">
          <span>{{ t.connections.swapLabel }}</span>
        </button>

        <div class="selector-box">
          <label class="selector-label">
            <span class="label-icon">{{ t.connections.sideBLabel }}</span>
            {{ t.connections.destination }}
          </label>
          <div class="search-wrapper">
            <input
              v-model="searchB"
              @focus="showDropdownB = true"
              @input="showDropdownB = true; store.clearConnectionFinderSelection('b')"
              :placeholder="t.connections.searchPlaceholder"
              class="search-input"
            />
            <button
              v-if="selectionB.port"
              class="clear-btn"
              :aria-label="t.connections.clearSelection"
              @click="clearSelectionB"
            >
              {{ t.app.closeSymbol }}
            </button>
          </div>

          <div v-if="showDropdownB && !selectionB.port" class="dropdown">
            <div
              v-for="item in filteredPortsB"
              :key="`${item.device.id}-${item.port.id}`"
              class="dropdown-item"
              @click="selectPortB(item.device, item.port)"
            >
              <span class="device-name">{{ item.device.name }}</span>
              <span class="port-info">
                <span class="port-label">{{ item.port.label }}</span>
                <span class="port-type" :class="item.port.type.toLowerCase()">
                  {{ t.devices.portTypes[item.port.type] }}
                </span>
                <span v-if="item.port.patchbayId" class="patch-id">#{{ item.port.patchbayId }}</span>
                <span v-else class="not-linked">{{ t.connections.unlinked }}</span>
              </span>
            </div>
            <div v-if="filteredPortsB.length === 0" class="no-results">
              {{ t.connections.noResults }}
            </div>
          </div>

          <div v-if="selectionB.port" class="selection-info">
            <div class="selected-device">{{ selectionB.device?.name }}</div>
            <div class="selected-port">
              {{ selectionB.port.label }}
              <span class="port-type" :class="selectionB.port.type.toLowerCase()">
                {{ t.devices.portTypes[selectionB.port.type] }}
              </span>
            </div>
            <div v-if="selectionB.port.patchbayId" class="patch-number">
              {{ t.connections.patchbayLabel }}: <strong>#{{ selectionB.port.patchbayId }}</strong>
            </div>
            <div v-else class="not-linked-warning">{{ t.connections.notLinkedWarning }}</div>
          </div>
        </div>
      </div>

      <div v-if="connectionResult" class="result-container">
        <div v-if="connectionResult.type === 'success'" class="result success">
          <div class="result-header">
            <span class="result-icon">{{ t.connections.successBadge }}</span>
            <h3>{{ t.connections.resultSuccessTitle }}</h3>
          </div>
          <div class="connection-diagram">
            <div class="patch-point">
              <span class="patch-number-big">#{{ connectionResult.patchA }}</span>
              <span class="patch-device">{{ connectionResult.deviceA }}</span>
              <span class="patch-port">{{ connectionResult.portA }}</span>
            </div>
            <div class="connection-line">
              <span class="cable-icon">{{ t.connections.cableLabel }}</span>
            </div>
            <div class="patch-point">
              <span class="patch-number-big">#{{ connectionResult.patchB }}</span>
              <span class="patch-device">{{ connectionResult.deviceB }}</span>
              <span class="patch-port">{{ connectionResult.portB }}</span>
            </div>
          </div>
          <p class="result-instruction">
            {{ t.connections.resultInstruction(connectionResult.patchA, connectionResult.patchB) }}
          </p>
          <div class="result-actions">
            <button class="primary-btn" @click="goToPatchbay">
              {{ t.connections.goToPatchbay }}
            </button>
            <button class="ghost-btn" @click="copyInstruction">
              {{ t.connections.copyInstruction }}
            </button>
          </div>
        </div>

        <div v-else class="result warning">
          <div class="result-header">
            <span class="result-icon">{{ t.connections.errorBadge }}</span>
            <h3>{{ t.connections.linkRequiredTitle }}</h3>
          </div>
          <p>{{ t.connections.linkRequiredHint }}</p>
          <div class="missing-grid">
            <div v-for="missing in connectionResult.missing" :key="missing.side" class="missing-card">
              <div class="missing-title">
                {{ missing.selection.device?.name }} - {{ missing.selection.port?.label }}
              </div>
              <div class="missing-actions">
                <select v-model="mappingChoice[missing.side]" class="patch-select">
                  <option :value="null" disabled>{{ t.connections.pickPatchPoint }}</option>
                  <option
                    v-for="patch in availablePatchPoints"
                    :key="patch.id"
                    :value="patch.id"
                  >
                    {{ t.connections.patchPointOption(patch.id, patch.name) }}
                  </option>
                </select>
                <button class="primary-btn" @click="mapMissingPort(missing)">
                  {{ t.connections.mapPort }}
                </button>
                <button class="ghost-btn" @click="linkNow(missing)">
                  {{ t.connections.linkNowFor(`${missing.selection.device?.name} - ${missing.selection.port?.label}`) }}
                </button>
              </div>
            </div>
          </div>
          <p class="hint">{{ connectionResult.message }}</p>
        </div>
      </div>

      <div v-else class="empty-state">
        <div class="empty-icon">{{ t.connections.emptyIcon }}</div>
        <p>{{ t.connections.emptyTitle }}</p>
      </div>
    </div>
  </div>
</template>

<style scoped>
.connection-finder {
  max-width: 1000px;
  margin: 0 auto;
  height: 100%;
  overflow: hidden;
  background: var(--surface-1);
  border-radius: var(--radius-3);
  border: 1px solid var(--border-default);
  box-shadow: var(--shadow-1);
  display: flex;
  flex-direction: column;
}

.finder-header {
  text-align: center;
  margin: var(--space-5) var(--space-5) var(--space-4);
}

.finder-header h2 {
  margin: 0 0 var(--space-2) 0;
  font-size: 1.8rem;
  color: var(--text-primary);
}

.subtitle {
  color: var(--text-secondary);
  margin: 0;
}

.return-hint {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: var(--space-3);
  padding: var(--space-3);
  margin: 0 var(--space-5) var(--space-4);
  border-radius: var(--radius-2);
  border: 1px solid rgba(106, 163, 111, 0.5);
  background: rgba(61, 122, 88, 0.18);
}

.finder-body {
  flex: 1;
  overflow-y: auto;
  padding: 0 var(--space-5) var(--space-5);
}

.selectors-container {
  display: flex;
  gap: var(--space-4);
  align-items: flex-start;
  margin-bottom: var(--space-5);
}

.selector-box {
  flex: 1;
  background-color: var(--surface-2);
  border-radius: var(--radius-3);
  padding: var(--space-4);
  position: relative;
  border: 1px solid var(--border-default);
}

.selector-label {
  display: flex;
  align-items: center;
  gap: var(--space-2);
  color: var(--text-primary);
  font-weight: 600;
  margin-bottom: var(--space-3);
}

.label-icon {
  background-color: var(--accent);
  color: #0f120e;
  width: 28px;
  height: 28px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  font-size: 0.9rem;
}

.selector-box:last-of-type .label-icon {
  background-color: var(--accent-2);
}

.search-wrapper {
  position: relative;
}

.search-input {
  width: 100%;
  padding: 12px 40px 12px 12px;
  background-color: var(--surface-1);
  border: 1px solid var(--border-default);
  border-radius: var(--radius-2);
  color: var(--text-primary);
  font-size: 1rem;
  box-sizing: border-box;
}

.search-input:focus {
  outline: none;
  border-color: var(--accent);
}

.clear-btn {
  position: absolute;
  right: 8px;
  top: 50%;
  transform: translateY(-50%);
  background: var(--surface-3);
  border: none;
  color: var(--text-primary);
  width: 24px;
  height: 24px;
  border-radius: 50%;
  cursor: pointer;
  font-size: 0.85rem;
  display: flex;
  align-items: center;
  justify-content: center;
}

.dropdown {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  background-color: var(--surface-1);
  border: 1px solid var(--border-default);
  border-radius: var(--radius-2);
  max-height: 300px;
  overflow-y: auto;
  z-index: 100;
  margin-top: 4px;
}

.dropdown-item {
  padding: var(--space-3);
  cursor: pointer;
  border-bottom: 1px solid var(--border-default);
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.dropdown-item:hover {
  background-color: var(--surface-2);
}

.dropdown-item:last-child {
  border-bottom: none;
}

.device-name {
  font-weight: 600;
  color: var(--text-primary);
}

.port-info {
  display: flex;
  align-items: center;
  gap: var(--space-2);
  font-size: 0.9rem;
}

.port-label {
  color: var(--text-secondary);
}

.port-type {
  font-size: 0.7rem;
  padding: 2px 6px;
  border-radius: var(--radius-1);
  text-transform: uppercase;
  background: var(--surface-3);
  color: var(--text-muted);
}

.patch-id {
  background-color: var(--accent);
  color: #0f120e;
  padding: 2px 6px;
  border-radius: var(--radius-1);
  font-size: 0.75rem;
  font-weight: 600;
}

.not-linked {
  color: var(--text-muted);
  font-style: italic;
  font-size: 0.8rem;
}

.no-results {
  padding: var(--space-4);
  text-align: center;
  color: var(--text-muted);
}

.selection-info {
  margin-top: var(--space-4);
  padding-top: var(--space-4);
  border-top: 1px solid var(--border-default);
}

.selected-device {
  font-weight: 600;
  color: var(--text-primary);
  font-size: 1.1rem;
}

.selected-port {
  display: flex;
  align-items: center;
  gap: var(--space-2);
  color: var(--text-secondary);
  margin-top: 4px;
}

.patch-number {
  margin-top: var(--space-3);
  color: var(--accent-2);
  font-size: 1.1rem;
}

.not-linked-warning {
  margin-top: var(--space-3);
  color: var(--warning);
}

.swap-btn {
  background-color: var(--surface-3);
  border: 1px solid var(--border-default);
  color: var(--text-primary);
  width: 64px;
  height: 64px;
  border-radius: var(--radius-round);
  cursor: pointer;
  font-size: 0.85rem;
  margin-top: 52px;
  transition: all 0.2s;
  text-transform: uppercase;
  letter-spacing: 0.1em;
}

.swap-btn:hover {
  border-color: var(--accent);
  color: var(--text-primary);
}

.result-container {
  margin-top: var(--space-4);
}

.result {
  background-color: var(--surface-2);
  border-radius: var(--radius-3);
  padding: var(--space-5);
  text-align: center;
  border: 1px solid var(--border-default);
}

.result.success {
  border-color: rgba(61, 122, 88, 0.7);
}

.result.warning {
  border-color: rgba(212, 154, 79, 0.6);
}

.result-header {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: var(--space-2);
  margin-bottom: var(--space-4);
}

.result-header h3 {
  margin: 0;
  color: var(--text-primary);
}

.result-icon {
  font-size: 1rem;
  text-transform: uppercase;
  color: var(--text-muted);
}

.connection-diagram {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: var(--space-4);
  margin: var(--space-4) 0;
}

.patch-point {
  background-color: var(--surface-1);
  border-radius: var(--radius-3);
  padding: var(--space-4);
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
  min-width: 150px;
  border: 1px solid var(--border-default);
}

.patch-number-big {
  font-size: 1.9rem;
  font-weight: bold;
  color: var(--accent-2);
}

.patch-device {
  font-weight: 600;
  color: var(--text-primary);
}

.patch-port {
  color: var(--text-secondary);
  font-size: 0.9rem;
}

.connection-line {
  color: var(--accent);
  font-size: 0.9rem;
}

.cable-icon {
  display: inline-block;
  animation: pulse 1.5s ease-in-out infinite;
  text-transform: uppercase;
  letter-spacing: 0.12em;
}

@keyframes pulse {
  0%, 100% { opacity: 0.6; }
  50% { opacity: 1; }
}

.result-instruction {
  color: var(--text-primary);
  font-size: 1rem;
  margin: var(--space-4) 0;
}

.result-actions {
  display: flex;
  justify-content: center;
  gap: var(--space-3);
  flex-wrap: wrap;
}

.primary-btn {
  background-color: var(--accent);
  color: #0f120e;
  border: none;
  padding: 10px 18px;
  border-radius: var(--radius-2);
  font-size: 0.95rem;
  font-weight: 600;
  cursor: pointer;
}

.ghost-btn {
  background-color: transparent;
  color: var(--text-secondary);
  border: 1px solid var(--border-default);
  padding: 10px 18px;
  border-radius: var(--radius-2);
  font-size: 0.95rem;
  font-weight: 600;
  cursor: pointer;
}

.missing-grid {
  display: grid;
  gap: var(--space-3);
  margin-top: var(--space-4);
}

.missing-card {
  padding: var(--space-3);
  border-radius: var(--radius-2);
  border: 1px solid var(--border-default);
  background: var(--surface-1);
  text-align: left;
}

.missing-title {
  font-weight: 600;
  margin-bottom: var(--space-2);
}

.missing-actions {
  display: flex;
  flex-wrap: wrap;
  gap: var(--space-2);
  align-items: center;
}

.patch-select {
  min-width: 180px;
  padding: 8px 10px;
  border-radius: var(--radius-2);
  border: 1px solid var(--border-default);
  background: var(--surface-2);
  color: var(--text-primary);
}

.hint {
  color: var(--text-muted) !important;
  font-size: 0.9rem;
  margin-top: var(--space-3);
}

.empty-state {
  text-align: center;
  padding: var(--space-6) var(--space-4);
  color: var(--text-muted);
}

.empty-icon {
  font-size: 2rem;
  margin-bottom: var(--space-3);
}

.empty-state p {
  font-size: 1.1rem;
  max-width: 400px;
  margin: 0 auto;
}

@media (max-width: 960px) {
  .selectors-container {
    flex-direction: column;
    align-items: stretch;
  }

  .swap-btn {
    margin: 0 auto;
  }

  .connection-diagram {
    flex-direction: column;
  }
}
</style>

================
File: src/style.css
================
:root {
  --font-ui: "IBM Plex Sans", "Segoe UI", sans-serif;
  --font-display: "Cormorant Garamond", "Times New Roman", serif;

  --surface-bg: #161411;
  --surface-1: #1f1c18;
  --surface-2: #26221d;
  --surface-3: #2f2a23;

  --text-primary: #f2eadc;
  --text-secondary: #b7b0a3;
  --text-muted: #8d877a;

  --border-default: #3b352c;

  --accent: #3d7a58;
  --accent-2: #6aa36f;
  --danger: #b04b3d;
  --warning: #d49a4f;

  --space-1: 4px;
  --space-2: 8px;
  --space-3: 12px;
  --space-4: 16px;
  --space-5: 24px;
  --space-6: 32px;
  --space-7: 40px;

  --radius-1: 4px;
  --radius-2: 8px;
  --radius-3: 12px;
  --radius-4: 18px;
  --radius-round: 999px;

  --shadow-1: 0 8px 20px rgba(0, 0, 0, 0.35);
  --shadow-2: 0 16px 40px rgba(0, 0, 0, 0.35);

  font-family: var(--font-ui);
  line-height: 1.5;
  font-weight: 400;
  color: var(--text-primary);
  background-color: var(--surface-bg);
  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

* {
  box-sizing: border-box;
}

body {
  margin: 0;
  padding: 0;
  min-width: 320px;
  min-height: 100vh;
  background-color: var(--surface-bg);
  color: var(--text-primary);
  overflow: hidden;
}

body::before {
  content: "";
  position: fixed;
  inset: 0;
  background:
    radial-gradient(circle at 20% 20%, rgba(61, 122, 88, 0.18), transparent 45%),
    radial-gradient(circle at 80% 10%, rgba(212, 154, 79, 0.1), transparent 35%),
    linear-gradient(180deg, rgba(22, 20, 17, 0.95), rgba(12, 11, 9, 0.98));
  z-index: -1;
}

button,
input,
select,
textarea {
  font-family: inherit;
}

h1,
h2,
h3,
h4 {
  font-family: var(--font-display);
  letter-spacing: 0.02em;
}

@keyframes fade-in {
  from {
    opacity: 0;
    transform: translateY(6px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

================
File: Dockerfile
================
# Build
FROM node:20-alpine AS build
WORKDIR /app

COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

# Runtime con 'serve' (sin Nginx)
FROM node:20-alpine
WORKDIR /app
RUN npm i -g serve
COPY --from=build /app/dist ./dist
ENV PORT=3000
EXPOSE 3000
CMD ["serve", "-s", "dist", "-l", "3000"]

================
File: index.html
================
<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="./src/assets/el-riche-mark.svg" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@500;600&family=IBM+Plex+Sans:wght@400;500;600&display=swap"
    rel="stylesheet"
  />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>El Riche Patchbay</title>
</head>

<body>
  <div id="app"></div>
  <script type="module" src="/src/main.ts"></script>
</body>

</html>

================
File: tsconfig.app.json
================
{
  "extends": "@vue/tsconfig/tsconfig.dom.json",
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    },

    "resolveJsonModule": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src/**/*.ts", "src/**/*.tsx", "src/**/*.vue"]
}

================
File: src/components/PatchBayGrid.vue
================
<script setup lang="ts">
import { ref, computed, watch, nextTick } from 'vue'
import { store, type PatchBayNode, type Device, type DevicePort } from '../store'
import ConfirmDialog from '../ui/ConfirmDialog.vue'
import { strings } from '../ui/strings'

const t = strings
const nodes = computed(() => store.patchbayNodes)
const selectedCell = ref<PatchBayNode | null>(null)
const showLinkSearch = ref(false)
const searchQuery = ref('')
const gridSearchQuery = ref('')
const showOverwriteConfirm = ref(false)
const overwriteTarget = ref<{ node: PatchBayNode; deviceName: string; portLabel: string } | null>(null)

const rowLabels = t.patchbay.rowLabels
const columnLabels = Array.from({ length: 48 }, (_, index) => index + 1)

// Helper to get connection info
const getConnection = (patchbayId: number) => {
  return store.getDeviceByPatchbayId(patchbayId)
}

const isLinked = (patchbayId: number) => {
  return !!getConnection(patchbayId)
}

const isMatch = (node: PatchBayNode) => {
  if (!gridSearchQuery.value) return false
  const query = gridSearchQuery.value.toLowerCase()

  if (node.name.toLowerCase().includes(query)) return true

  const connection = getConnection(node.id)
  if (connection) {
    if (connection.device.name.toLowerCase().includes(query)) return true
    if (connection.port.label.toLowerCase().includes(query)) return true
  }

  return false
}

const isHighlightedConnection = (patchbayId: number) => {
  return store.highlightedPatchIds.includes(patchbayId)
}

const selectionBannerText = computed(() => {
  if (store.pendingLink) {
    return t.patchbay.linkingBanner(store.pendingLink.deviceName, store.pendingLink.portLabel)
  }
  return t.patchbay.linkingFallback
})

const getSectionNodes = (sectionIndex: number) => {
  return nodes.value.slice((sectionIndex - 1) * 96, sectionIndex * 96)
}

const getCellTooltip = (patchbayId: number) => {
  const connection = getConnection(patchbayId)
  if (!connection) return ''
  return t.patchbay.tooltip(connection.device.name, connection.port.label)
}

const handleCellClick = async (node: PatchBayNode) => {
  if (store.selectionMode) {
    const existing = getConnection(node.id)
    if (existing) {
      overwriteTarget.value = {
        node,
        deviceName: existing.device.name,
        portLabel: existing.port.label,
      }
      showOverwriteConfirm.value = true
      return
    }
    await store.completeLink(node.id)
  } else {
    selectedCell.value = node
  }
}

const closePopup = () => {
  selectedCell.value = null
  showLinkSearch.value = false
  searchQuery.value = ''
}

const handleUnlink = async () => {
  if (selectedCell.value) {
    const connection = getConnection(selectedCell.value.id)
    if (connection) {
      await store.unlinkPort(connection.device.id, connection.port.id)
    }
  }
}

const openLinkSearch = () => {
  showLinkSearch.value = true
}

const confirmOverwrite = async () => {
  if (overwriteTarget.value) {
    await store.completeLink(overwriteTarget.value.node.id)
  }
  showOverwriteConfirm.value = false
  overwriteTarget.value = null
}

const cancelOverwrite = () => {
  showOverwriteConfirm.value = false
  overwriteTarget.value = null
}

// Search Logic
const filteredDevices = computed(() => {
  if (!searchQuery.value) return store.devices
  const query = searchQuery.value.toLowerCase()
  return store.devices.filter(d => d.name.toLowerCase().includes(query))
})

const selectDeviceForLink = async (device: Device, port: DevicePort) => {
  if (selectedCell.value) {
    await store.linkPatchbayToDevice(selectedCell.value.id, device.id, port.id)
    closePopup()
  }
}

watch(() => store.patchbayFocusId, async (focusId) => {
  if (!focusId) return
  await nextTick()
  const target = document.querySelector(`[data-patch-id=\"${focusId}\"]`) as HTMLElement | null
  if (target) {
    target.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' })
  }
  store.patchbayFocusId = null
})
</script>

<template>
  <div class="main-container" :class="{ 'selection-mode': store.selectionMode }">
    <div class="top-controls">
      <div v-if="store.selectionMode" class="selection-banner">
        <span>{{ selectionBannerText }}</span>
        <button @click="store.cancelLinking()">{{ t.patchbay.cancel }}</button>
      </div>

      <div v-if="store.highlightedPatchIds.length > 0" class="highlight-banner">
        <span>{{ t.patchbay.showingConnection(store.highlightedPatchIds[0], store.highlightedPatchIds[1]) }}</span>
        <button @click="store.highlightedPatchIds = []">{{ t.patchbay.clearHighlights }}</button>
      </div>

      <div class="grid-controls">
        <input
          v-model="gridSearchQuery"
          :placeholder="t.patchbay.searchPlaceholder"
          class="grid-search-input"
        />
        <div class="grid-legend">
          <span class="legend-title">{{ t.patchbay.legendTitle }}</span>
          <span class="legend-chip linked">{{ t.patchbay.legendLinked }}</span>
          <span class="legend-chip open">{{ t.patchbay.legendOpen }}</span>
          <span class="legend-chip match">{{ t.patchbay.legendMatch }}</span>
          <span class="legend-chip highlight">{{ t.patchbay.legendHighlight }}</span>
        </div>
      </div>
    </div>

    <div class="grid-wrapper">
      <div v-for="sectionIndex in 3" :key="sectionIndex" class="grid-section" :class="'section-' + sectionIndex">
        <div class="grid-corner"></div>
        <div v-for="col in columnLabels" :key="`col-${sectionIndex}-${col}`" class="grid-col-label">
          {{ col }}
        </div>
        <div class="grid-row-label">{{ rowLabels[0] }}</div>
        <div
          v-for="item in getSectionNodes(sectionIndex).slice(0, 48)"
          :key="item.id"
          class="grid-cell"
          :class="{
            linked: isLinked(item.id),
            open: !isLinked(item.id),
            'highlight-match': isMatch(item),
            'highlight-connection': isHighlightedConnection(item.id),
          }"
          :data-patch-id="item.id"
          :data-tooltip="getCellTooltip(item.id) || null"
          @click="handleCellClick(item)"
        >
          <div class="cell-content">
            <span class="cell-text">{{ item.id }}</span>
          </div>
        </div>
        <div class="grid-row-label">{{ rowLabels[1] }}</div>
        <div
          v-for="item in getSectionNodes(sectionIndex).slice(48, 96)"
          :key="item.id"
          class="grid-cell"
          :class="{
            linked: isLinked(item.id),
            open: !isLinked(item.id),
            'highlight-match': isMatch(item),
            'highlight-connection': isHighlightedConnection(item.id),
          }"
          :data-patch-id="item.id"
          :data-tooltip="getCellTooltip(item.id) || null"
          @click="handleCellClick(item)"
        >
          <div class="cell-content">
            <span class="cell-text">{{ item.id }}</span>
          </div>
        </div>
      </div>
    </div>

    <ConfirmDialog
      v-if="showOverwriteConfirm && overwriteTarget"
      :title="t.confirm.overwriteTitle"
      :message="t.confirm.overwriteMessage(overwriteTarget.deviceName, overwriteTarget.portLabel)"
      @confirm="confirmOverwrite"
      @cancel="cancelOverwrite"
    />

    <div v-if="selectedCell && !showLinkSearch" class="modal-overlay" @click="closePopup">
      <div class="modal-content" @click.stop>
        <h2>{{ t.patchbay.patchPointTitle(selectedCell.id) }}</h2>
        <p><strong>{{ t.patchbay.nameLabel }}:</strong> {{ selectedCell.name }}</p>
        <p><strong>{{ t.patchbay.typeLabel }}:</strong> {{ selectedCell.type }}</p>
        <p><strong>{{ t.patchbay.descriptionLabel }}:</strong> {{ selectedCell.description }}</p>

        <div class="connection-status">
          <h3>{{ t.patchbay.connectionLabel }}</h3>
          <div v-if="getConnection(selectedCell.id)" class="connected-info">
            <p>
              {{ t.patchbay.connectedTo }}:
              <strong>{{ getConnection(selectedCell.id)?.device.name }}</strong>
            </p>
            <p>
              {{ t.patchbay.portLabel }}:
              <strong>{{ getConnection(selectedCell.id)?.port.label }}</strong>
            </p>
            <button class="unlink-btn" @click="handleUnlink">{{ t.patchbay.unlink }}</button>
          </div>
          <div v-else class="disconnected-info">
            <p>{{ t.patchbay.notConnected }}</p>
            <button class="link-btn" @click="openLinkSearch">{{ t.patchbay.linkDeviceAction }}</button>
          </div>
        </div>

        <button class="close-btn-main" @click="closePopup">{{ t.patchbay.close }}</button>
      </div>
    </div>

    <div v-if="showLinkSearch" class="modal-overlay" @click="closePopup">
      <div class="modal-content search-modal" @click.stop>
        <div class="modal-header">
          <h2>{{ t.patchbay.linkDeviceTitle(selectedCell?.id || 0) }}</h2>
          <button class="close-btn" @click="closePopup">{{ t.app.closeSymbol }}</button>
        </div>

        <input
          v-model="searchQuery"
          :placeholder="t.patchbay.searchDevicesPlaceholder"
          class="search-input"
          autofocus
        />

        <div class="device-search-list">
          <div v-for="device in filteredDevices" :key="device.id" class="search-device-item">
            <div class="device-name">{{ device.name }}</div>
            <div class="device-ports">
              <button
                v-for="port in device.ports"
                :key="port.id"
                class="port-select-btn"
                :class="{ active: port.patchbayId === selectedCell?.id, occupied: port.patchbayId && port.patchbayId !== selectedCell?.id }"
                :disabled="!!(port.patchbayId && port.patchbayId !== selectedCell?.id)"
                @click="selectDeviceForLink(device, port)"
              >
                {{ port.label }}
                <span v-if="port.patchbayId && port.patchbayId !== selectedCell?.id" class="occupied-tag">
                  {{ t.patchbay.occupiedTag(port.patchbayId) }}
                </span>
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<style scoped>
.main-container {
  display: flex;
  flex-direction: column;
  gap: var(--space-4);
  padding: var(--space-5);
  background-color: var(--surface-1);
  width: 100%;
  height: 100%;
  border-radius: var(--radius-3);
  border: 1px solid var(--border-default);
  box-shadow: var(--shadow-1);
  overflow: auto;
}

.selection-mode {
  border: 2px solid rgba(61, 122, 88, 0.9);
  box-shadow: 0 0 0 2px rgba(61, 122, 88, 0.2);
}

.selection-banner {
  background-color: rgba(61, 122, 88, 0.2);
  color: var(--text-primary);
  padding: var(--space-2) var(--space-3);
  text-align: center;
  font-weight: 600;
  display: flex;
  justify-content: center;
  gap: var(--space-3);
  align-items: center;
  border-radius: var(--radius-2);
  border: 1px solid rgba(61, 122, 88, 0.4);
}

.selection-banner button {
  background: var(--surface-1);
  color: var(--text-secondary);
  border: 1px solid var(--border-default);
  padding: 4px 12px;
  border-radius: var(--radius-2);
  cursor: pointer;
}

.highlight-banner {
  background: linear-gradient(120deg, rgba(61, 122, 88, 0.3), rgba(212, 154, 79, 0.25));
  color: var(--text-primary);
  padding: var(--space-2) var(--space-3);
  text-align: center;
  font-weight: 500;
  display: flex;
  justify-content: center;
  gap: var(--space-3);
  align-items: center;
  border-radius: var(--radius-2);
  border: 1px solid rgba(212, 154, 79, 0.3);
}

.highlight-banner button {
  background: transparent;
  color: var(--text-secondary);
  border: 1px solid var(--border-default);
  padding: 4px 12px;
  border-radius: var(--radius-2);
  cursor: pointer;
}

.grid-controls {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: var(--space-3);
  flex-wrap: wrap;
}

.grid-search-input {
  width: 100%;
  max-width: 360px;
  padding: 10px 12px;
  background-color: var(--surface-2);
  border: 1px solid var(--border-default);
  color: var(--text-primary);
  border-radius: var(--radius-2);
}

.grid-legend {
  display: flex;
  align-items: center;
  gap: var(--space-2);
  flex-wrap: wrap;
}

.legend-title {
  color: var(--text-muted);
  font-size: 0.85rem;
  text-transform: uppercase;
  letter-spacing: 0.12em;
}

.legend-chip {
  padding: 4px 10px;
  border-radius: var(--radius-round);
  font-size: 0.8rem;
  border: 1px solid var(--border-default);
  color: var(--text-secondary);
}

.legend-chip.linked {
  border-color: rgba(106, 163, 111, 0.6);
}

.legend-chip.open {
  border-color: rgba(141, 135, 122, 0.6);
}

.legend-chip.match {
  border-color: rgba(212, 154, 79, 0.6);
}

.legend-chip.highlight {
  border-color: rgba(61, 122, 88, 0.7);
}

.grid-wrapper {
  display: flex;
  flex-direction: column;
  gap: var(--space-4);
  width: 100%;
}

.grid-section {
  display: grid;
  grid-template-columns: 32px repeat(48, minmax(22px, 1fr));
  grid-template-rows: auto repeat(2, minmax(28px, 1fr));
  gap: 4px;
  width: 100%;
  min-width: 1280px;
  position: relative;
}

.grid-corner {
  position: sticky;
  left: 0;
  top: 0;
  background: var(--surface-1);
  z-index: 2;
}

.grid-col-label {
  font-size: 0.65rem;
  color: var(--text-muted);
  text-align: center;
  position: sticky;
  top: 0;
  background: var(--surface-1);
  padding-bottom: 4px;
  z-index: 2;
}

.grid-row-label {
  font-size: 0.75rem;
  color: var(--text-muted);
  text-align: center;
  display: flex;
  align-items: center;
  justify-content: center;
  position: sticky;
  left: 0;
  background: var(--surface-1);
  z-index: 1;
}

.grid-cell {
  background-color: var(--surface-2);
  border: 1px solid var(--border-default);
  border-radius: var(--radius-1);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background-color 0.2s, border-color 0.2s, transform 0.2s;
  height: 34px;
  position: relative;
}

.grid-cell.open {
  background-color: var(--surface-2);
}

.grid-cell.linked {
  background-color: rgba(61, 122, 88, 0.25);
  border-color: rgba(61, 122, 88, 0.6);
}

.grid-cell:hover {
  border-color: rgba(212, 154, 79, 0.6);
  transform: translateY(-1px);
}

.grid-cell[data-tooltip]:hover::after {
  content: attr(data-tooltip);
  position: absolute;
  left: 50%;
  top: -34px;
  transform: translateX(-50%);
  background: var(--surface-3);
  color: var(--text-primary);
  padding: 6px 10px;
  border-radius: var(--radius-2);
  border: 1px solid var(--border-default);
  white-space: nowrap;
  font-size: 0.75rem;
  z-index: 20;
  box-shadow: var(--shadow-1);
}

.grid-cell.highlight-match {
  background-color: rgba(212, 154, 79, 0.35);
  border-color: rgba(212, 154, 79, 0.7);
  box-shadow: 0 0 6px rgba(212, 154, 79, 0.3);
  z-index: 1;
}

.grid-cell.highlight-connection {
  background-color: rgba(61, 122, 88, 0.6);
  border-color: rgba(61, 122, 88, 0.9);
  box-shadow: 0 0 18px rgba(61, 122, 88, 0.5);
  z-index: 10;
  animation: connection-pulse 1s ease-in-out infinite;
  transform: scale(1.08);
  border-width: 2px;
}

.grid-cell.highlight-connection .cell-text {
  font-weight: bold;
  font-size: 0.75rem;
}

@keyframes connection-pulse {
  0%, 100% {
    box-shadow: 0 0 12px rgba(61, 122, 88, 0.5);
  }
  50% {
    box-shadow: 0 0 18px rgba(106, 163, 111, 0.7);
  }
}

.cell-text {
  font-size: 0.6rem;
  color: var(--text-primary);
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
  padding: 1px;
}

.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(7, 6, 5, 0.7);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.modal-content {
  background-color: var(--surface-2);
  padding: var(--space-5);
  border-radius: var(--radius-3);
  min-width: 300px;
  box-shadow: var(--shadow-2);
  color: var(--text-primary);
  border: 1px solid var(--border-default);
}

.modal-content.search-modal {
  width: 640px;
  max-height: 80vh;
  display: flex;
  flex-direction: column;
  padding: 0;
}

.modal-header {
  padding: var(--space-4);
  border-bottom: 1px solid var(--border-default);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.close-btn {
  background: none;
  border: none;
  color: var(--text-secondary);
  font-size: 1.5rem;
  cursor: pointer;
}

.connection-status {
  margin: var(--space-4) 0;
  padding: var(--space-3);
  background-color: var(--surface-1);
  border-radius: var(--radius-2);
  border: 1px solid var(--border-default);
}

.link-btn {
  background-color: var(--accent);
  color: #0c0e0b;
  border: none;
  padding: 8px 16px;
  border-radius: var(--radius-2);
  cursor: pointer;
  margin-top: var(--space-2);
  font-weight: 600;
}

.unlink-btn {
  background-color: var(--danger);
  color: #fdf7ee;
  border: none;
  padding: 8px 16px;
  border-radius: var(--radius-2);
  cursor: pointer;
  margin-top: var(--space-2);
}

.close-btn-main {
  margin-top: var(--space-3);
  padding: 0.5rem 1rem;
  background-color: var(--surface-3);
  color: var(--text-primary);
  border: 1px solid var(--border-default);
  border-radius: var(--radius-2);
  cursor: pointer;
}

.search-input {
  margin: var(--space-4);
  padding: 10px;
  background-color: var(--surface-1);
  border: 1px solid var(--border-default);
  color: var(--text-primary);
  border-radius: var(--radius-2);
}

.device-search-list {
  overflow-y: auto;
  padding: 0 var(--space-4) var(--space-4) var(--space-4);
}

.search-device-item {
  margin-bottom: var(--space-3);
  background-color: var(--surface-1);
  padding: var(--space-3);
  border-radius: var(--radius-2);
  border: 1px solid var(--border-default);
}

.device-name {
  font-weight: bold;
  margin-bottom: var(--space-2);
  color: var(--text-primary);
}

.device-ports {
  display: flex;
  flex-wrap: wrap;
  gap: var(--space-2);
}

.port-select-btn {
  background-color: var(--surface-2);
  border: 1px solid var(--border-default);
  color: var(--text-primary);
  padding: 4px 8px;
  border-radius: var(--radius-2);
  cursor: pointer;
  font-size: 0.85rem;
}

.port-select-btn:hover:not(:disabled) {
  background-color: rgba(61, 122, 88, 0.25);
}

.port-select-btn.active {
  background-color: var(--accent);
  color: #0c0e0b;
  border-color: var(--accent);
}

.port-select-btn.occupied {
  opacity: 0.5;
  cursor: not-allowed;
  background-color: var(--surface-2);
}

.occupied-tag {
  font-size: 0.7rem;
  color: var(--text-muted);
}

@media (max-width: 960px) {
  .main-container {
    padding: var(--space-3);
  }

  .grid-section {
    min-width: 960px;
  }
}
</style>

================
File: src/lib/api.ts
================
// API client for patchbay backend
const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:8088'

// API Types (snake_case from backend)
export interface ApiPatchbayPoint {
  id: number
  name: string
  description: string
  type: string
}

export interface ApiPort {
  id: string
  label: string
  type: 'Input' | 'Output' | 'Other'
  patchbay_id: number | null
}

export interface ApiDevice {
  id: number
  name: string
  type: string
  ports: ApiPort[]
  image_url?: string | null
  image_updated_at?: string | null
}

export interface ApiState {
  patchbay_points: ApiPatchbayPoint[]
  devices: ApiDevice[]
}

export interface ApiPortLinkRequest {
  patchbay_id: number
}

export interface ApiPortLinkResponse extends ApiPort {
  unlinked_port_id?: string | null
}

export interface ApiDeviceCreate {
  name: string
  type: string
  ports: Array<{
    label: string
    type: 'Input' | 'Output' | 'Other'
    patchbay_id: number | null
  }>
}

export interface ApiDeviceUpdate {
  name: string
  type: string
  ports: Array<{
    id?: string
    label: string
    type: 'Input' | 'Output' | 'Other'
    patchbay_id?: number | null
  }>
}

// HTTP client
async function request<T>(path: string, options?: RequestInit): Promise<T> {
  const url = `${API_URL}${path}`
  const body = options?.body
  const headers: HeadersInit = {
    ...options?.headers,
  }
  
  try {
    const response = await fetch(url, {
      ...options,
      headers: {
        ...(body instanceof FormData ? {} : { 'Content-Type': 'application/json' }),
        ...headers,
      },
    })

    if (!response.ok) {
      const errorText = await response.text()
      throw new Error(`HTTP ${response.status}: ${errorText}`)
    }

    return await response.json()
  } catch (error) {
    console.error(`API request failed: ${path}`, error)
    throw error
  }
}

// API methods
export const api = {
  async getState(): Promise<ApiState> {
    return request<ApiState>('/state')
  },

  async createDevice(payload: ApiDeviceCreate): Promise<ApiDevice> {
    return request<ApiDevice>('/devices', {
      method: 'POST',
      body: JSON.stringify(payload),
    })
  },

  async deleteDevice(deviceId: number): Promise<ApiDevice> {
    return request<ApiDevice>(`/devices/${deviceId}`, {
      method: 'DELETE',
    })
  },

  async updateDevice(deviceId: number, payload: ApiDeviceUpdate): Promise<ApiDevice> {
    return request<ApiDevice>(`/devices/${deviceId}`, {
      method: 'PUT',
      body: JSON.stringify(payload),
    })
  },

  async linkPort(portId: string, patchbayId: number): Promise<ApiPortLinkResponse> {
    return request<ApiPortLinkResponse>(`/ports/${portId}/link`, {
      method: 'POST',
      body: JSON.stringify({ patchbay_id: patchbayId }),
    })
  },

  async updatePortPatchbay(portId: string, patchbayId: number | null): Promise<ApiPort> {
    return request<ApiPort>(`/ports/${portId}/patchbay`, {
      method: 'PUT',
      body: JSON.stringify({ patchbay_id: patchbayId }),
    })
  },

  async unlinkPort(portId: string): Promise<ApiPort> {
    return request<ApiPort>(`/ports/${portId}/unlink`, {
      method: 'POST',
    })
  },

  async parseDeviceFromImage(image: File): Promise<ApiDevice> {
    const formData = new FormData()
    formData.append('image', image)

    return request<ApiDevice>('/devices/parse-image', {
      method: 'POST',
      body: formData,
    })
  },

  async uploadDeviceImage(deviceId: number, image: File): Promise<ApiDevice> {
    // Client-side validation
    if (!image.type.startsWith('image/')) {
      throw new Error('Invalid file type. Please upload an image file.')
    }
    const MAX_SIZE = 12 * 1024 * 1024 // 12MB
    if (image.size > MAX_SIZE) {
      throw new Error('Image too large. Maximum size is 12MB.')
    }

    const formData = new FormData()
    formData.append('image', image)

    return request<ApiDevice>(`/devices/${deviceId}/image`, {
      method: 'POST',
      body: formData,
    })
  },

  buildAbsoluteUrl(relativeOrAbsolute: string): string {
    if (relativeOrAbsolute.startsWith('http://') || relativeOrAbsolute.startsWith('https://')) {
      return relativeOrAbsolute
    }
    return `${API_URL}${relativeOrAbsolute}`
  },

  getDeviceImageSrc(imageUrl: string | null | undefined, imageUpdatedAt: string | null | undefined): string | null {
    if (!imageUrl) return null
    
    const base = this.buildAbsoluteUrl(imageUrl)
    const cacheBust = imageUpdatedAt ? `?v=${encodeURIComponent(imageUpdatedAt)}` : ''
    return base + cacheBust
  },
}

================
File: src/vite-env.d.ts
================
/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly VITE_API_URL: string
}

interface ImportMeta {
  readonly env: ImportMetaEnv
}

================
File: README.md
================
# üéõÔ∏è Audio Tech Web - Patchbay Manager

Sistema web para gestionar y visualizar conexiones de patchbay en estudios de audio. Permite administrar dispositivos de audio y sus puertos, vincul√°ndolos con puntos espec√≠ficos del patchbay.

## ‚ú® Caracter√≠sticas

- **Visualizaci√≥n de Patchbay**: Grilla interactiva de 96 puntos (4 filas x 24 columnas)
- **Gesti√≥n de Dispositivos**: CRUD completo para equipos de audio (preamps, compresores, EQs, etc.)
- **Administraci√≥n de Puertos**: Cada dispositivo puede tener m√∫ltiples puertos (Input/Output/Other)
- **Vinculaci√≥n Din√°mica**: Conecta puertos de dispositivos a puntos del patchbay
- **B√∫squeda y Filtrado**: Encuentra r√°pidamente dispositivos y conexiones
- **Persistencia con API**: Datos guardados en PostgreSQL mediante FastAPI backend

## üõ†Ô∏è Tech Stack

### Frontend
- **Frontend**: Vue 3 + TypeScript
- **Build Tool**: Vite
- **State Management**: Store reactivo con Vue Composition API
- **Estilos**: CSS vanilla con dise√±o oscuro profesional

### Backend
- **API**: FastAPI
- **Database**: PostgreSQL 16
- **ORM**: SQLAlchemy 2.0
- **Migrations**: Alembic

## üìã Requisitos Previos

- Node.js 18+
- Docker & Docker Compose
- npm o yarn

## üöÄ Instalaci√≥n

### Backend (API + Database)

1. **Ir a la carpeta del backend**
   ```bash
   cd api-backend
   ```

2. **Copiar variables de entorno**
   ```bash
   cp .env.example .env
   ```

3. **Levantar servicios con Docker**
   ```bash
   docker compose up --build
   ```

   Esto levanta:
   - PostgreSQL en puerto `5435`
   - API FastAPI en puerto `8088`
   - pgAdmin en puerto `8090`

4. **Verificar API**
   - Swagger: http://localhost:8088/docs
   - Health: http://localhost:8088/health

### Frontend (Vue App)

1. **Instalar dependencias**
   ```bash
   npm install
   ```

2. **Configurar variables de entorno**

   ```bash
   cp .env.example .env
   ```

   Editar `.env` si necesitas otro host:
   ```env
   VITE_API_URL=http://localhost:8088
   ```

3. **Iniciar servidor de desarrollo**
   ```bash
   npm run dev
   ```

   La app estar√° disponible en http://localhost:5173

## üìÅ Estructura del Proyecto

```
pepper/
‚îú‚îÄ‚îÄ src/                        # Frontend Vue
‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PatchBayGrid.vue    # Grilla visual del patchbay
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DevicesManager.vue  # Gesti√≥n de dispositivos
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ConnectionFinder.vue
‚îÇ   ‚îú‚îÄ‚îÄ store/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts            # Estado global + API calls
‚îÇ   ‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ api.ts              # Cliente HTTP para backend
‚îÇ   ‚îú‚îÄ‚îÄ data/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ patchbayData.json   # Datos est√°ticos del patchbay
‚îÇ   ‚îú‚îÄ‚îÄ App.vue
‚îÇ   ‚îî‚îÄ‚îÄ main.ts
‚îî‚îÄ‚îÄ api-backend/                # Backend FastAPI
    ‚îú‚îÄ‚îÄ app/
    ‚îÇ   ‚îú‚îÄ‚îÄ api/routes/         # Endpoints HTTP
    ‚îÇ   ‚îú‚îÄ‚îÄ models/             # Modelos SQLAlchemy
    ‚îÇ   ‚îú‚îÄ‚îÄ schemas/            # Schemas Pydantic
    ‚îÇ   ‚îî‚îÄ‚îÄ services/           # L√≥gica de negocio
    ‚îú‚îÄ‚îÄ alembic/                # Migraciones DB
    ‚îî‚îÄ‚îÄ docker-compose.yml
```

## üóÑÔ∏è Modelo de Datos

La API maneja tres entidades principales:

### Devices
Equipos de audio (preamps, synths, etc.)
- `id`, `name`, `type`

### Ports
Puertos de entrada/salida de cada device
- `id`, `device_id`, `label`, `type` (Input/Output/Other), `patchbay_id`

### Patchbay Points
Puntos f√≠sicos del patchbay
- `id`, `name`, `description`, `type`

## üéÆ Uso

### Gestionar Dispositivos
1. Ir a la pesta√±a **Devices**
2. Click en **Add Device** para crear un nuevo equipo
3. Agregar puertos con su tipo (Input/Output/Other)
4. Guardar el dispositivo

### Vincular a Patchbay
1. Seleccionar un dispositivo
2. En un puerto, click en **Link**
3. Se abrir√° el patchbay - seleccionar el punto deseado
4. La conexi√≥n queda establecida

### Ver Conexiones
- En el **Patchbay**, los puntos conectados muestran el dispositivo vinculado
- En **Devices**, cada puerto muestra su punto de patchbay asignado

## üìú Scripts Disponibles

### Frontend
```bash
npm run dev      # Servidor de desarrollo
npm run build    # Build de producci√≥n
npm run preview  # Preview del build
```

### Backend
```bash
docker compose up         # Levantar servicios
docker compose down       # Detener servicios
docker compose logs api   # Ver logs de la API
```

## üê≥ Docker

Para correr todo el stack completo:

```bash
# Backend
cd api-backend && docker compose up -d

# Frontend (en otra terminal)
npm run dev
```

O para deployar el frontend tambi√©n con Docker, usar el `docker-compose.yml` en la ra√≠z.

## üîß API Endpoints

- `GET /state` - Estado completo (patchbay + devices)
- `POST /devices` - Crear dispositivo con puertos
- `DELETE /devices/{id}` - Borrar dispositivo
- `POST /ports/{id}/link` - Vincular puerto a patchbay
- `POST /ports/{id}/unlink` - Desvincular puerto
- `PUT /ports/{id}/patchbay` - Actualizar patchbay de un puerto

Ver documentaci√≥n completa en http://localhost:8088/docs

## üìÑ Licencia

MIT


---

Desarrollado con üéöÔ∏è para t√©cnicos de audio

================
File: package.json
================
{
  "name": "audio-tech-web",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vue-tsc -b && vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "pinia": "^3.0.3",
    "vue": "^3.5.18",
    "vue-router": "^4.5.1"
  },
  "devDependencies": {
    "@types/node": "^20.11.30",
    "@vitejs/plugin-vue": "^6.0.1",
    "@vue/tsconfig": "^0.7.0",
    "typescript": "~5.8.3",
    "vite": "^7.1.2",
    "vue-tsc": "^3.0.5"
  }
}

================
File: docker-compose.yml
================
services:
  web:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: pepper-frontend
    ports:
      - "8080:3000"
    restart: unless-stopped
    networks:
      - pepper-network

networks:
  pepper-network:
    driver: bridge

================
File: src/components/DevicesManager.vue
================
<script setup lang="ts">
import { ref, computed, watch, onBeforeUnmount, onMounted } from 'vue'
import { api } from '../lib/api'
import { store, type Device, type DevicePort } from '../store'
import { strings } from '../ui/strings'
import ConfirmDialog from '../ui/ConfirmDialog.vue'

const t = strings

const searchQuery = ref('')
const isLoading = ref(false)
const isDesktop = ref(window.innerWidth >= 1024)

const updateViewport = () => {
  isDesktop.value = window.innerWidth >= 1024
}

onMounted(() => {
  window.addEventListener('resize', updateViewport)
})

const showError = (message: string) => {
  store.pushToast({ type: 'error', message })
}

const filteredDevices = computed(() => {
  if (!searchQuery.value) return store.devices
  const query = searchQuery.value.toLowerCase()
  return store.devices.filter(device =>
    device.name.toLowerCase().includes(query) ||
    device.type.toLowerCase().includes(query) ||
    device.ports.some(p => p.label.toLowerCase().includes(query))
  )
})

const selectedDevice = ref<Device | null>(null)
const showAddModal = ref(false)
const addDeviceMode = ref<'manual' | 'ai'>('manual')
const editingDeviceId = ref<number | null>(null)
const editSnapshot = ref<{ device: { name: string; type: string }; ports: DevicePort[] } | null>(null)
const deleteTarget = ref<Device | null>(null)
const DRAFT_STORAGE_KEY = 'el-riche.addDeviceDraft'
const LEGACY_DRAFT_STORAGE_KEY = 'pepper.addDeviceDraft'

const deviceTypeOptions = t.devices.deviceTypes
const portTypeOptions = Object.keys(t.devices.portTypes) as Array<keyof typeof t.devices.portTypes>
const fallbackDeviceType = deviceTypeOptions[deviceTypeOptions.length - 1]

const newDevice = ref({
  name: '',
  type: deviceTypeOptions[0],
})

const newPorts = ref<Array<{ id?: string; label: string; type: 'Input' | 'Output' | 'Other'; patchbayId?: number | null }>>([])

const aiPreviewUrl = ref<string | null>(null)
const aiLoading = ref(false)
const aiStatusMessage = ref<string | null>(null)
const isEditing = computed(() => editingDeviceId.value !== null)

// Image upload state
const pendingImageFile = ref<File | null>(null)
const pendingImagePreviewUrl = ref<string | null>(null)
const pendingImageError = ref<string | null>(null)
const isUploadingImage = ref(false)

const aiStep = computed(() => {
  if (!aiPreviewUrl.value) return 'upload'
  if (aiLoading.value) return 'processing'
  if (aiStatusMessage.value) return 'review'
  return 'upload'
})

const addPort = () => {
  newPorts.value.push({
    label: t.devices.addPortLabel(newPorts.value.length + 1),
    type: portTypeOptions[0],
    patchbayId: null,
  })
}

const removePort = (index: number) => {
  newPorts.value.splice(index, 1)
}

const selectDevice = (device: Device) => {
  selectedDevice.value = device
}

const closeDetail = () => {
  selectedDevice.value = null
}

const normalizeDeviceType = (value: string | null | undefined) => {
  const raw = value?.trim()
  if (!raw) return fallbackDeviceType
  const match = deviceTypeOptions.find(option => option.toLowerCase() === raw.toLowerCase())
  return match || fallbackDeviceType
}

const saveDraft = () => {
  if (isEditing.value) return
  const draft = {
    device: newDevice.value,
    ports: newPorts.value,
  }
  localStorage.setItem(DRAFT_STORAGE_KEY, JSON.stringify(draft))
}

const loadDraft = () => {
  const raw = localStorage.getItem(DRAFT_STORAGE_KEY) || localStorage.getItem(LEGACY_DRAFT_STORAGE_KEY)
  if (!raw) return
  try {
    const draft = JSON.parse(raw)
    if (draft?.device?.name !== undefined && draft?.device?.type !== undefined) {
      newDevice.value = {
        name: String(draft.device.name ?? ''),
        type: normalizeDeviceType(String(draft.device.type ?? fallbackDeviceType)),
      }
    }
    if (Array.isArray(draft?.ports)) {
      newPorts.value = draft.ports
        .filter((port: any) => port?.label && port?.type)
        .map((port: any) => ({
          label: String(port.label),
          type: port.type as 'Input' | 'Output' | 'Other',
          patchbayId: port.patchbayId ?? null,
          id: port.id || undefined,
        }))
    }
  } catch (err) {
    console.warn('Failed to load add device draft', err)
  }
}

const clearDraft = () => {
  localStorage.removeItem(DRAFT_STORAGE_KEY)
  localStorage.removeItem(LEGACY_DRAFT_STORAGE_KEY)
}

const resetAddForm = (clear = false) => {
  newDevice.value = { name: '', type: deviceTypeOptions[0] }
  newPorts.value = []
  addDeviceMode.value = 'manual'
  aiStatusMessage.value = null
  if (aiPreviewUrl.value) {
    URL.revokeObjectURL(aiPreviewUrl.value)
  }
  aiPreviewUrl.value = null
  clearPendingImage()
  if (clear) {
    clearDraft()
  }
}

const closeAddModal = () => {
  showAddModal.value = false
  if (isEditing.value) {
    editingDeviceId.value = null
    editSnapshot.value = null
    resetAddForm()
  } else {
    saveDraft()
  }
}

const openAddModal = () => {
  showAddModal.value = true
  loadDraft()
}

const openEditModal = (device: Device) => {
  editingDeviceId.value = device.id
  editSnapshot.value = {
    device: { name: device.name, type: normalizeDeviceType(device.type) },
    ports: device.ports.map(port => ({ ...port })),
  }
  newDevice.value = { name: device.name, type: normalizeDeviceType(device.type) }
  newPorts.value = device.ports.map(port => ({
    id: port.id,
    label: port.label,
    type: port.type,
    patchbayId: port.patchbayId,
  }))
  addDeviceMode.value = 'manual'
  aiStatusMessage.value = null
  showAddModal.value = true
}

const setAiImageFile = (file: File | null) => {
  if (aiPreviewUrl.value) {
    URL.revokeObjectURL(aiPreviewUrl.value)
  }
  aiPreviewUrl.value = file ? URL.createObjectURL(file) : null
}

const setPendingImageFile = (file: File | null) => {
  // Revoke old preview URL to prevent memory leaks
  if (pendingImagePreviewUrl.value) {
    URL.revokeObjectURL(pendingImagePreviewUrl.value)
  }
  
  pendingImageFile.value = file
  pendingImagePreviewUrl.value = file ? URL.createObjectURL(file) : null
  pendingImageError.value = null
  
  // Validate file
  if (file) {
    if (!file.type.startsWith('image/')) {
      pendingImageError.value = 'Invalid file type. Please upload an image file (JPG, PNG, etc.)'
      pendingImageFile.value = null
      pendingImagePreviewUrl.value = null
    } else if (file.size > 12 * 1024 * 1024) {
      pendingImageError.value = 'Image too large. Maximum size is 12MB.'
      pendingImageFile.value = null
      pendingImagePreviewUrl.value = null
    }
  }
}

const clearPendingImage = () => {
  if (pendingImagePreviewUrl.value) {
    URL.revokeObjectURL(pendingImagePreviewUrl.value)
  }
  pendingImageFile.value = null
  pendingImagePreviewUrl.value = null
  pendingImageError.value = null
}

const getDeviceImageSrc = (device: Device) => {
  return api.getDeviceImageSrc(device.imageUrl, device.imageUpdatedAt)
}

const handleResetForm = () => {
  if (isEditing.value && editSnapshot.value) {
    newDevice.value = { ...editSnapshot.value.device }
    newPorts.value = editSnapshot.value.ports.map(port => ({
      id: port.id,
      label: port.label,
      type: port.type,
      patchbayId: port.patchbayId,
    }))
    aiStatusMessage.value = null
    return
  }
  resetAddForm(true)
}

const handleAiFileChange = async (event: Event) => {
  const input = event.target as HTMLInputElement
  const file = input.files?.[0]
  input.value = ''
  if (!file) return

  setAiImageFile(file)
  // Also set as pending image for auto-attach
  setPendingImageFile(file)
  aiStatusMessage.value = null
  aiLoading.value = true

  try {
    const device = await api.parseDeviceFromImage(file)
    newDevice.value = {
      name: device.name || '',
      type: normalizeDeviceType(device.type),
    }
    newPorts.value = device.ports.map((port) => ({
      label: port.label,
      type: port.type,
      patchbayId: null,
    }))
    aiStatusMessage.value = t.devices.aiDraftReady
  } catch (err: any) {
    showError(err.message || strings.toast.imageParseFailed)
    console.error('Error parsing device image:', err)
  } finally {
    aiLoading.value = false
  }
}

const handleManualImageChange = (event: Event) => {
  const input = event.target as HTMLInputElement
  const file = input.files?.[0]
  input.value = ''
  if (!file) return
  
  setPendingImageFile(file)
}

const handleAddDevice = async () => {
  if (newPorts.value.length === 0) {
    showError(t.devices.validation.addPortFirst)
    return
  }
  if (!newDevice.value.name.trim()) {
    showError(t.devices.validation.nameRequired)
    return
  }

  isLoading.value = true

  try {
    const ports: DevicePort[] = newPorts.value.map((p) => ({
      id: p.id || '',
      label: p.label,
      type: p.type,
      patchbayId: p.patchbayId ?? null,
    }))

    let deviceId: number

    if (isEditing.value && editingDeviceId.value !== null) {
      const updated = await store.updateDevice(editingDeviceId.value, {
        name: newDevice.value.name,
        type: newDevice.value.type,
        ports,
      })
      deviceId = updated.id
      
      // Update selectedDevice reference
      if (selectedDevice.value?.id === deviceId) {
        selectedDevice.value = updated
      }
    } else {
      const created = await store.addDevice({
        name: newDevice.value.name,
        type: newDevice.value.type,
        ports,
      })
      deviceId = created.id
    }

    // Upload image if one is pending
    if (pendingImageFile.value) {
      try {
        isUploadingImage.value = true
        const updatedDevice = await store.uploadDeviceImage(deviceId, pendingImageFile.value)
        
        // Update selectedDevice reference if needed
        if (selectedDevice.value?.id === deviceId) {
          selectedDevice.value = updatedDevice
        }
      } catch (imgErr: any) {
        showError(`Device saved, but image upload failed: ${imgErr.message || 'Unknown error'}`)
        console.error('Error uploading device image:', imgErr)
      } finally {
        isUploadingImage.value = false
      }
    }

    store.pushToast({ type: 'success', message: strings.toast.deviceSaved })
    showAddModal.value = false
    editingDeviceId.value = null
    editSnapshot.value = null
    resetAddForm(true)
  } catch (err: any) {
    showError(err.message || strings.toast.deviceSaveFailed)
    console.error('Error saving device:', err)
  } finally {
    isLoading.value = false
  }
}

const requestDeleteDevice = (device: Device) => {
  deleteTarget.value = device
}

const confirmDeleteDevice = async () => {
  if (!deleteTarget.value) return
  isLoading.value = true
  try {
    await store.deleteDevice(deleteTarget.value.id)
    store.pushToast({ type: 'success', message: strings.toast.deviceDeleted })
    if (selectedDevice.value?.id === deleteTarget.value.id) {
      closeDetail()
    }
  } catch (err: any) {
    showError(err.message || strings.toast.deviceDeleteFailed)
    console.error('Error deleting device:', err)
  } finally {
    isLoading.value = false
    deleteTarget.value = null
  }
}

const cancelDeleteDevice = () => {
  deleteTarget.value = null
}

const handleLinkPort = (port: DevicePort) => {
  if (!selectedDevice.value) return
  store.startLinkingPort({
    portId: port.id,
    deviceId: selectedDevice.value.id,
    deviceName: selectedDevice.value.name,
    portLabel: port.label,
  }, {
    returnTab: 'devices',
    returnPayload: {
      resume: 'devices',
      deviceId: selectedDevice.value.id,
      portId: port.id,
      reopenDeviceDetail: true,
    },
  })
}

const handleUnlinkPort = async (port: DevicePort) => {
  if (!selectedDevice.value) return
  try {
    await store.unlinkPort(selectedDevice.value.id, port.id)
  } catch (err: any) {
    showError(err.message || strings.toast.unlinkFailed)
    console.error('Error unlinking port:', err)
  }
}

const handleGoToPatchbay = (port: DevicePort) => {
  if (!port.patchbayId) return
  store.highlightedPatchIds = [port.patchbayId]
  store.patchbayFocusId = port.patchbayId
  store.setTab('patchbay')
}

watch([newDevice, newPorts], () => {
  if (showAddModal.value && !isEditing.value) {
    saveDraft()
  }
}, { deep: true })

watch(() => store.activeTab, (tab) => {
  if (tab !== 'devices') return
  const payload = store.lastLinkReturnPayload as { resume?: string; deviceId?: number; reopenDeviceDetail?: boolean } | null
  if (!payload || payload.resume !== 'devices' || !payload.reopenDeviceDetail) return
  const deviceId = payload.deviceId
  if (!deviceId) return
  const device = store.devices.find(item => item.id === deviceId)
  if (device) {
    selectedDevice.value = device
  }
  store.clearLinkReturnPayload()
})

onBeforeUnmount(() => {
  window.removeEventListener('resize', updateViewport)
  if (aiPreviewUrl.value) {
    URL.revokeObjectURL(aiPreviewUrl.value)
  }
  if (pendingImagePreviewUrl.value) {
    URL.revokeObjectURL(pendingImagePreviewUrl.value)
  }
})
</script>

<template>
  <div class="devices-container">
    <div class="header">
      <div class="title-block">
        <h2>{{ t.devices.title }}</h2>
        <span v-if="isLoading" class="status-pill">{{ t.devices.saving }}</span>
      </div>
      <div class="header-actions">
        <input
          v-model="searchQuery"
          :placeholder="t.devices.searchPlaceholder"
          class="search-input"
        />
        <button class="add-btn" @click="openAddModal">{{ t.devices.addDevice }}</button>
      </div>
    </div>

    <div class="devices-layout">
      <div class="devices-list">
        <div
          v-for="device in filteredDevices"
          :key="device.id"
          class="device-card"
          :class="{ active: selectedDevice?.id === device.id }"
          @click="selectDevice(device)"
        >
          <div v-if="device.imageUrl" class="device-thumbnail">
            <img :src="getDeviceImageSrc(device) || ''" :alt="device.name" />
          </div>
          <div v-else class="device-thumbnail-placeholder">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
              <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
              <circle cx="8.5" cy="8.5" r="1.5"></circle>
              <polyline points="21 15 16 10 5 21"></polyline>
            </svg>
          </div>
          <div class="device-header">
            <h3>{{ device.name }}</h3>
            <div class="device-meta">
              <span class="device-type">{{ device.type }}</span>
              <button class="edit-btn" @click.stop="openEditModal(device)" :aria-label="t.devices.editDevice">
                <svg viewBox="0 0 24 24" aria-hidden="true">
                  <path d="M4 16.25V20h3.75L19.81 7.94l-3.75-3.75L4 16.25zm14.71-9.46a1 1 0 0 0 0-1.41l-1.09-1.09a1 1 0 0 0-1.41 0l-1.13 1.13 3.75 3.75 1.88-1.88z"/>
                </svg>
              </button>
            </div>
          </div>
          <div class="device-info">
            <span>{{ t.devices.portsCount(device.ports.length) }}</span>
          </div>
        </div>
      </div>

      <div v-if="selectedDevice && isDesktop" class="device-detail-panel">
        <div class="panel-header">
          <div class="panel-title">
            <h3>{{ selectedDevice.name }}</h3>
            <span class="device-type">{{ selectedDevice.type }}</span>
          </div>
          <div class="panel-actions">
            <button class="ghost-btn" @click="openEditModal(selectedDevice)">{{ t.devices.editDevice }}</button>
            <button class="ghost-btn" @click="closeDetail">{{ t.devices.closeDetail }}</button>
          </div>
        </div>

        <div class="device-details">
          <div v-if="selectedDevice.imageUrl" class="device-detail-image">
            <img :src="getDeviceImageSrc(selectedDevice) || ''" :alt="selectedDevice.name" />
          </div>
          
          <p><strong>{{ t.devices.typeLabel }}:</strong> {{ selectedDevice.type }}</p>
          <p><strong>{{ t.devices.idLabel }}:</strong> {{ selectedDevice.id }}</p>

          <h4>{{ t.devices.portsConfig }}</h4>
          <div class="ports-list">
            <div v-for="port in selectedDevice.ports" :key="port.id" class="port-item">
              <div class="port-info">
                <span class="port-label">{{ port.label }}</span>
                <span class="port-type">{{ t.devices.portTypes[port.type] }}</span>
              </div>

              <div class="port-actions">
                <span v-if="port.patchbayId" class="port-connection">
                  {{ t.devices.linkedTo(port.patchbayId) }}
                  <button class="link-action-btn unlink" @click.stop="handleUnlinkPort(port)">{{ t.devices.unlink }}</button>
                  <button class="link-action-btn ghost" @click.stop="handleGoToPatchbay(port)">
                    {{ t.devices.goToPatch(port.patchbayId) }}
                  </button>
                </span>
                <span v-else class="port-connection empty">
                  {{ t.devices.notConnected }}
                  <button class="link-action-btn link" @click.stop="handleLinkPort(port)">{{ t.devices.link }}</button>
                </span>
              </div>
            </div>
          </div>
        </div>

        <div class="panel-footer">
          <button class="delete-btn" @click="requestDeleteDevice(selectedDevice)">{{ t.devices.deleteDevice }}</button>
        </div>
      </div>
    </div>

    <div v-if="selectedDevice && !isDesktop" class="modal-overlay" @click="closeDetail">
      <div class="modal-content" @click.stop>
        <div class="modal-header">
          <h2>{{ selectedDevice.name }}</h2>
          <button class="close-btn" @click="closeDetail">{{ t.app.closeSymbol }}</button>
        </div>

        <div class="device-details">
          <div v-if="selectedDevice.imageUrl" class="device-detail-image">
            <img :src="getDeviceImageSrc(selectedDevice) || ''" :alt="selectedDevice.name" />
          </div>
          
          <p><strong>{{ t.devices.typeLabel }}:</strong> {{ selectedDevice.type }}</p>
          <p><strong>{{ t.devices.idLabel }}:</strong> {{ selectedDevice.id }}</p>

          <h3>{{ t.devices.portsConfig }}</h3>
          <div class="ports-list">
            <div v-for="port in selectedDevice.ports" :key="port.id" class="port-item">
              <div class="port-info">
                <span class="port-label">{{ port.label }}</span>
                <span class="port-type">{{ t.devices.portTypes[port.type] }}</span>
              </div>

              <div class="port-actions">
                <span v-if="port.patchbayId" class="port-connection">
                  {{ t.devices.linkedTo(port.patchbayId) }}
                  <button class="link-action-btn unlink" @click.stop="handleUnlinkPort(port)">{{ t.devices.unlink }}</button>
                  <button class="link-action-btn ghost" @click.stop="handleGoToPatchbay(port)">
                    {{ t.devices.goToPatch(port.patchbayId) }}
                  </button>
                </span>
                <span v-else class="port-connection empty">
                  {{ t.devices.notConnected }}
                  <button class="link-action-btn link" @click.stop="handleLinkPort(port)">{{ t.devices.link }}</button>
                </span>
              </div>
            </div>
          </div>
        </div>

        <div class="modal-actions">
          <button class="delete-btn" @click="requestDeleteDevice(selectedDevice)">{{ t.devices.deleteDevice }}</button>
        </div>
      </div>
    </div>

    <div v-if="showAddModal" class="modal-overlay" @click="closeAddModal">
      <div class="modal-content small add-device-modal" @click.stop>
        <div class="modal-header">
          <h2>{{ isEditing ? t.devices.editDevice : t.devices.addNewDevice }}</h2>
          <button class="close-btn" @click="closeAddModal">{{ t.app.closeSymbol }}</button>
        </div>
        <div class="add-device-tabs">
          <button
            class="tab-btn"
            :class="{ active: addDeviceMode === 'manual' }"
            @click="addDeviceMode = 'manual'"
          >
            {{ t.devices.tabManual }}
          </button>
          <button
            class="tab-btn"
            :class="{ active: addDeviceMode === 'ai' }"
            @click="addDeviceMode = 'ai'"
          >
            {{ t.devices.tabAutoDetect }}
          </button>
        </div>
        <div class="form-content">
          <div v-if="addDeviceMode === 'manual'" class="manual-form">
            <div class="form-group">
              <label>{{ t.devices.nameLabel }}</label>
              <input v-model="newDevice.name" :placeholder="t.devices.namePlaceholder" />
            </div>
            <div class="form-group">
              <label>{{ t.devices.typeLabel }}</label>
              <select v-model="newDevice.type">
                <option v-for="option in deviceTypeOptions" :key="option" :value="option">
                  {{ option }}
                </option>
              </select>
            </div>
            <div class="form-group">
              <label>Device Image (optional)</label>
              <p class="help-text">Maximum 12MB. Supported formats: JPG, PNG, WebP</p>
              <label class="ai-upload-btn">
                {{ pendingImagePreviewUrl || (isEditing && selectedDevice?.imageUrl) ? 'Change Image' : 'Upload Image' }}
                <input 
                  type="file" 
                  accept="image/*" 
                  @change="handleManualImageChange"
                  class="ai-file-input"
                />
              </label>
              <div v-if="pendingImageError" class="error-text">{{ pendingImageError }}</div>
              <div v-if="pendingImagePreviewUrl" class="ai-preview">
                <img :src="pendingImagePreviewUrl" alt="Preview" />
              </div>
              <div v-else-if="isEditing && selectedDevice?.imageUrl && !pendingImageFile" class="ai-preview">
                <img :src="getDeviceImageSrc(selectedDevice) || ''" :alt="selectedDevice.name" />
              </div>
              <button v-if="pendingImagePreviewUrl" class="ghost-btn" @click="clearPendingImage" type="button" style="margin-top: 8px;">Remove Image</button>
            </div>
            <div class="form-group ports-section">
              <div class="ports-header">
                <label>{{ t.devices.portsLabel }}</label>
                <button class="add-port-btn" @click="addPort">{{ t.devices.addPort }}</button>
              </div>
              <div class="ports-editor">
                <div v-for="(port, index) in newPorts" :key="index" class="port-edit-row">
                  <input v-model="port.label" :placeholder="t.devices.portNamePlaceholder" class="port-name-input" />
                  <select v-model="port.type" class="port-type-select">
                    <option v-for="option in portTypeOptions" :key="option" :value="option">
                      {{ t.devices.portTypes[option] }}
                    </option>
                  </select>
                  <button class="remove-port-btn" @click="removePort(index)">{{ t.devices.removePort }}</button>
                </div>
                <div v-if="newPorts.length === 0" class="ports-empty">
                  {{ t.devices.noPorts }}
                </div>
              </div>
            </div>
          </div>

          <div v-else class="ai-form">
            <div class="ai-stepper">
              <span :class="{ active: aiStep === 'upload' }">{{ t.devices.aiSteps.upload }}</span>
              <span :class="{ active: aiStep === 'processing' }">{{ t.devices.aiSteps.processing }}</span>
              <span :class="{ active: aiStep === 'review' }">{{ t.devices.aiSteps.review }}</span>
            </div>
            <p class="ai-help">{{ t.devices.aiHelp }}</p>
            <label class="ai-upload-btn">
              {{ t.devices.aiUpload }}
              <input
                class="ai-file-input"
                type="file"
                accept="image/*"
                capture="environment"
                @change="handleAiFileChange"
              />
            </label>
            <div v-if="aiPreviewUrl" class="ai-preview">
              <img :src="aiPreviewUrl" alt="Device preview" />
              <p class="help-text">This image will be attached to the device when you save.</p>
            </div>
            <div v-if="aiLoading" class="ai-progress">
              <span class="spinner"></span>
              <span>{{ t.devices.aiProcessing }}</span>
            </div>
            <div v-if="aiStatusMessage" class="ai-status">
              {{ aiStatusMessage }}
              <button class="ghost-btn" @click="addDeviceMode = 'manual'">
                {{ t.devices.aiReviewDraft }}
              </button>
            </div>
          </div>
        </div>
        <div class="form-footer">
          <button class="reset-btn" @click="handleResetForm" type="button">{{ t.devices.resetForm }}</button>
          <button 
            class="save-btn" 
            @click="handleAddDevice" 
            :disabled="!newDevice.name || newPorts.length === 0 || isUploadingImage"
          >
            <span v-if="isUploadingImage">Uploading image...</span>
            <span v-else>{{ isEditing ? t.devices.updateDevice : t.devices.createDevice }}</span>
          </button>
        </div>
      </div>
    </div>

    <ConfirmDialog
      v-if="deleteTarget"
      :title="t.confirm.deleteDeviceTitle"
      :message="t.confirm.deleteDeviceMessage(deleteTarget.name)"
      @confirm="confirmDeleteDevice"
      @cancel="cancelDeleteDevice"
    />
  </div>
</template>

<style scoped>
.devices-container {
  padding: var(--space-5);
  color: var(--text-primary);
  height: 100%;
  overflow: auto;
  background: var(--surface-1);
  border-radius: var(--radius-3);
  border: 1px solid var(--border-default);
  box-shadow: var(--shadow-1);
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--space-4);
  flex-wrap: wrap;
  gap: var(--space-3);
}

.title-block {
  display: flex;
  align-items: center;
  gap: var(--space-2);
}

.status-pill {
  padding: 4px 10px;
  border-radius: var(--radius-round);
  background: rgba(212, 154, 79, 0.2);
  border: 1px solid rgba(212, 154, 79, 0.5);
  color: var(--warning);
  font-size: 0.8rem;
}

.header-actions {
  display: flex;
  gap: var(--space-2);
  align-items: center;
}

.search-input {
  padding: 8px 12px;
  background-color: var(--surface-2);
  border: 1px solid var(--border-default);
  color: var(--text-primary);
  border-radius: var(--radius-2);
  min-width: 220px;
}

.add-btn {
  background-color: var(--accent);
  color: #0f120e;
  border: none;
  padding: 8px 16px;
  border-radius: var(--radius-2);
  cursor: pointer;
  font-weight: 600;
}

.devices-layout {
  display: grid;
  grid-template-columns: minmax(280px, 360px) 1fr;
  gap: var(--space-4);
}

.devices-list {
  display: flex;
  flex-direction: column;
  gap: var(--space-3);
}

.device-card {
  background-color: var(--surface-2);
  border: 1px solid var(--border-default);
  border-radius: var(--radius-3);
  padding: var(--space-3);
  cursor: pointer;
  transition: transform 0.2s, box-shadow 0.2s, border-color 0.2s;
}

.device-card:hover {
  transform: translateY(-2px);
  box-shadow: var(--shadow-1);
}

.device-card.active {
  border-color: rgba(61, 122, 88, 0.6);
}

.device-header {
  display: flex;
  justify-content: space-between;
  align-items: start;
  margin-bottom: var(--space-2);
}

.device-header h3 {
  margin: 0;
  font-size: 1.1rem;
  color: var(--text-primary);
}

.device-type {
  font-size: 0.8rem;
  background-color: var(--surface-3);
  padding: 2px 8px;
  border-radius: var(--radius-2);
  color: var(--text-secondary);
}

.device-meta {
  display: inline-flex;
  align-items: center;
  gap: var(--space-2);
}

.edit-btn {
  width: 28px;
  height: 28px;
  border-radius: var(--radius-2);
  border: 1px solid var(--border-default);
  background-color: var(--surface-1);
  color: var(--text-secondary);
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

.edit-btn svg {
  width: 16px;
  height: 16px;
  fill: currentColor;
}

.edit-btn:hover {
  border-color: var(--accent);
  color: var(--text-primary);
}

.device-info {
  font-size: 0.9rem;
  color: var(--text-secondary);
}

.device-detail-panel {
  background: var(--surface-2);
  border: 1px solid var(--border-default);
  border-radius: var(--radius-3);
  padding: var(--space-4);
  display: flex;
  flex-direction: column;
  gap: var(--space-4);
  min-height: 360px;
}

.panel-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: var(--space-2);
}

.panel-title h3 {
  margin: 0 0 4px;
}

.panel-actions {
  display: flex;
  gap: var(--space-2);
}

.device-details h4 {
  margin-top: var(--space-4);
}

.ports-list {
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
  margin-top: var(--space-2);
}

.port-item {
  background-color: var(--surface-1);
  padding: var(--space-2) var(--space-3);
  border-radius: var(--radius-2);
  display: flex;
  justify-content: space-between;
  align-items: center;
  border: 1px solid var(--border-default);
}

.port-info {
  display: flex;
  align-items: center;
  gap: var(--space-2);
}

.port-label {
  font-weight: 600;
  color: var(--text-primary);
}

.port-type {
  font-size: 0.75rem;
  padding: 2px 6px;
  border-radius: var(--radius-1);
  text-transform: uppercase;
  background: var(--surface-3);
  color: var(--text-muted);
}

.port-actions {
  display: flex;
  align-items: center;
}

.port-connection {
  font-size: 0.85rem;
  color: var(--text-secondary);
  display: flex;
  align-items: center;
  gap: var(--space-2);
}

.port-connection.empty {
  color: var(--text-muted);
  font-style: italic;
}

.link-action-btn {
  padding: 4px 8px;
  border-radius: var(--radius-1);
  border: none;
  cursor: pointer;
  font-size: 0.8rem;
  font-weight: 600;
}

.link-action-btn.link {
  background-color: var(--accent);
  color: #0f120e;
}

.link-action-btn.unlink {
  background-color: var(--danger);
  color: #fef7ee;
}

.link-action-btn.ghost {
  background: transparent;
  border: 1px solid var(--border-default);
  color: var(--text-secondary);
}

.panel-footer {
  display: flex;
  justify-content: flex-end;
}

.delete-btn {
  background-color: var(--danger);
  color: #fef7ee;
  border: none;
  padding: 8px 16px;
  border-radius: var(--radius-2);
  cursor: pointer;
}

.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(7, 6, 5, 0.7);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.modal-content {
  background-color: var(--surface-2);
  width: 90%;
  max-width: 600px;
  max-height: 80vh;
  border-radius: var(--radius-3);
  display: flex;
  flex-direction: column;
  box-shadow: var(--shadow-2);
  border: 1px solid var(--border-default);
}

.modal-content.small {
  max-width: 420px;
}

.modal-content.add-device-modal {
  max-height: 80vh;
  display: flex;
  flex-direction: column;
  max-width: 520px;
}

.modal-content.add-device-modal .form-content {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  min-height: 0;
}

.manual-form,
.ai-form {
  padding: var(--space-4);
}

.add-device-tabs {
  display: flex;
  gap: var(--space-2);
  padding: var(--space-2) var(--space-4);
  border-bottom: 1px solid var(--border-default);
  background-color: var(--surface-2);
}

.tab-btn {
  flex: 1;
  padding: 8px 10px;
  border-radius: var(--radius-2);
  border: 1px solid var(--border-default);
  background-color: var(--surface-1);
  color: var(--text-secondary);
  font-weight: 600;
  cursor: pointer;
}

.tab-btn.active {
  background-color: var(--accent);
  color: #0f120e;
  border-color: var(--accent);
}

.form-footer {
  padding: var(--space-3) var(--space-4);
  border-top: 1px solid var(--border-default);
  background-color: var(--surface-2);
  display: flex;
  gap: var(--space-2);
}

.form-footer .save-btn {
  flex: 1;
  margin-top: 0;
}

.reset-btn {
  background-color: var(--surface-3);
  color: var(--text-primary);
  border: 1px solid var(--border-default);
  padding: 10px;
  border-radius: var(--radius-2);
  cursor: pointer;
  font-weight: 600;
  flex: 1;
}

.modal-header {
  padding: var(--space-4);
  border-bottom: 1px solid var(--border-default);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.modal-header h2 {
  margin: 0;
  color: var(--text-primary);
}

.close-btn {
  background: none;
  border: none;
  color: var(--text-secondary);
  font-size: 1.5rem;
  cursor: pointer;
}

.device-details {
  padding: var(--space-4);
  overflow-y: auto;
}

.modal-actions {
  padding: var(--space-4);
  border-top: 1px solid var(--border-default);
  display: flex;
  justify-content: flex-end;
  gap: var(--space-2);
}

.form-content {
  padding: var(--space-4);
  display: flex;
  flex-direction: column;
  gap: var(--space-3);
}

.form-group {
  display: flex;
  flex-direction: column;
  gap: 5px;
}

.form-group label {
  color: var(--text-secondary);
  font-size: 0.9rem;
}

.form-group input,
.form-group select {
  padding: 8px;
  background-color: var(--surface-1);
  border: 1px solid var(--border-default);
  border-radius: var(--radius-2);
  color: var(--text-primary);
}

.ai-form {
  display: flex;
  flex-direction: column;
  gap: var(--space-3);
}

.ai-stepper {
  display: flex;
  gap: var(--space-2);
  font-size: 0.8rem;
  text-transform: uppercase;
  letter-spacing: 0.12em;
  color: var(--text-muted);
}

.ai-stepper span.active {
  color: var(--accent-2);
}

.ai-help {
  color: var(--text-secondary);
  font-size: 0.9rem;
}

.ai-upload-btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 10px 12px;
  border-radius: var(--radius-2);
  border: 1px dashed var(--border-default);
  background-color: var(--surface-1);
  color: var(--text-primary);
  cursor: pointer;
  font-weight: 600;
}

.ai-file-input {
  display: none;
}

.ai-preview {
  border-radius: var(--radius-2);
  border: 1px solid var(--border-default);
  overflow: hidden;
  max-height: 200px;
}

.ai-preview img {
  width: 100%;
  height: auto;
  display: block;
  object-fit: cover;
}

.ai-progress {
  display: flex;
  align-items: center;
  gap: var(--space-2);
  color: var(--text-secondary);
}

.spinner {
  width: 16px;
  height: 16px;
  border: 2px solid var(--border-default);
  border-top-color: var(--accent);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

.ai-status {
  color: var(--accent-2);
  font-size: 0.9rem;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: var(--space-2);
}

.save-btn {
  background-color: var(--accent);
  color: #0f120e;
  border: none;
  padding: 10px;
  border-radius: var(--radius-2);
  cursor: pointer;
  font-weight: 600;
  margin-top: 10px;
}

.save-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.ports-editor {
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
  max-height: 200px;
  overflow-y: auto;
  padding-right: 4px;
}

.ports-section {
  flex: 1;
  min-height: 0;
  display: flex;
  flex-direction: column;
}

.ports-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}

.ports-header .add-port-btn {
  margin: 0;
  padding: 4px 10px;
  font-size: 0.85rem;
}

.ports-empty {
  color: var(--text-muted);
  font-style: italic;
  text-align: center;
  padding: var(--space-4);
  background-color: var(--surface-1);
  border-radius: var(--radius-2);
  border: 1px dashed var(--border-default);
}

.port-edit-row {
  display: flex;
  gap: var(--space-2);
  align-items: center;
}

.port-name-input {
  flex: 1;
  padding: 6px 8px;
  background-color: var(--surface-1);
  border: 1px solid var(--border-default);
  border-radius: var(--radius-2);
  color: var(--text-primary);
}

.port-type-select {
  padding: 6px 8px;
  background-color: var(--surface-1);
  border: 1px solid var(--border-default);
  border-radius: var(--radius-2);
  color: var(--text-primary);
  min-width: 90px;
}

.remove-port-btn {
  background-color: var(--danger);
  color: #fef7ee;
  border: none;
  padding: 6px 8px;
  border-radius: var(--radius-2);
  cursor: pointer;
  font-size: 0.8rem;
}

.add-port-btn {
  background-color: var(--surface-3);
  color: var(--text-primary);
  border: 1px dashed var(--border-default);
  padding: 8px;
  border-radius: var(--radius-2);
  cursor: pointer;
  margin-top: 4px;
}

.ghost-btn {
  background: transparent;
  border: 1px solid var(--border-default);
  color: var(--text-secondary);
  padding: 6px 12px;
  border-radius: var(--radius-2);
  cursor: pointer;
  font-weight: 600;
}

/* Device image styles */
.device-thumbnail {
  width: 100%;
  height: 100px;
  overflow: hidden;
  border-radius: var(--radius-2);
  margin-bottom: var(--space-2);
}

.device-thumbnail img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.device-thumbnail-placeholder {
  width: 100%;
  height: 100px;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: var(--surface-3);
  border-radius: var(--radius-2);
  margin-bottom: var(--space-2);
  color: var(--text-muted);
}

.device-thumbnail-placeholder svg {
  width: 32px;
  height: 32px;
  stroke-width: 1.5;
}

.device-detail-image {
  width: 100%;
  max-width: 400px;
  margin-bottom: var(--space-4);
  border-radius: var(--radius-2);
  overflow: hidden;
  border: 1px solid var(--border-default);
}

.device-detail-image img {
  width: 100%;
  height: auto;
  display: block;
}

.image-preview {
  margin-top: var(--space-2);
  border: 1px solid var(--border-default);
  border-radius: var(--radius-2);
  padding: var(--space-2);
  background-color: var(--surface-1);
}

.image-preview img {
  width: 100%;
  max-width: 300px;
  height: auto;
  display: block;
  margin-bottom: var(--space-2);
  border-radius: var(--radius-2);
}

.help-text {
  font-size: 0.85rem;
  color: var(--text-muted);
  margin-top: 4px;
  margin-bottom: 0;
}

.error-text {
  font-size: 0.85rem;
  color: var(--danger);
  margin-top: 4px;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

@media (max-width: 1024px) {
  .devices-layout {
    grid-template-columns: 1fr;
  }

  .device-detail-panel {
    display: none;
  }
}
</style>

================
File: src/App.vue
================
<script setup lang="ts">
import { computed, onMounted } from 'vue'
import PatchBayGrid from './components/PatchBayGrid.vue'
import DevicesManager from './components/DevicesManager.vue'
import ConnectionFinder from './components/ConnectionFinder.vue'
import ToastHost from './ui/ToastHost.vue'
import { strings } from './ui/strings'
import { store } from './store'
import logoUrl from './assets/el-riche-mark.svg'

const t = strings

onMounted(() => {
  store.loadData()
})

const statusLabel = computed(() => {
  if (store.loading) return t.app.syncing
  if (store.error) return t.app.syncIssue
  return t.app.synced
})

const notifyComingSoon = () => {
  store.pushToast({ type: 'info', message: t.app.comingSoon })
}
</script>

<template>
  <div class="app-container">
    <div v-if="store.loading" class="loading-overlay">
      <div class="loading-card">{{ t.app.loadingData }}</div>
    </div>

    <header class="topbar">
      <div class="brand">
        <img class="brand-mark" :src="logoUrl" alt="" />
        <div class="brand-text">
          <span class="brand-title">{{ t.app.name }}</span>
          <span class="brand-subtitle">{{ t.app.tagline }}</span>
        </div>
      </div>

      <div class="topbar-center">
        <div class="status-chip" :class="{ loading: store.loading, error: store.error }">
          <span class="status-dot"></span>
          <span class="status-text">{{ statusLabel }}</span>
        </div>
        <div class="topbar-actions">
          <button class="ghost-btn" @click="notifyComingSoon">{{ t.app.export }}</button>
          <button class="ghost-btn" @click="notifyComingSoon">{{ t.app.help }}</button>
          <button class="ghost-btn" @click="notifyComingSoon">{{ t.app.shortcuts }}</button>
        </div>
      </div>

      <nav class="main-nav">
        <button
          :class="{ active: store.activeTab === 'patchbay' }"
          @click="store.setTab('patchbay')"
        >
          {{ t.nav.patchbay }}
        </button>
        <button
          :class="{ active: store.activeTab === 'devices' }"
          @click="store.setTab('devices')"
        >
          {{ t.nav.devices }}
        </button>
        <button
          :class="{ active: store.activeTab === 'connections' }"
          @click="store.setTab('connections')"
        >
          {{ t.nav.connections }}
        </button>
      </nav>
    </header>

    <main class="content-area">
      <PatchBayGrid v-if="store.activeTab === 'patchbay'" />
      <DevicesManager v-if="store.activeTab === 'devices'" />
      <ConnectionFinder v-if="store.activeTab === 'connections'" />
    </main>

    <ToastHost />
  </div>
</template>

<style scoped>
.app-container {
  display: flex;
  flex-direction: column;
  height: 100vh;
  animation: fade-in 0.6s ease-out;
}

.topbar {
  display: grid;
  grid-template-columns: auto 1fr auto;
  gap: var(--space-4);
  align-items: center;
  padding: var(--space-3) var(--space-5);
  background: rgba(26, 23, 19, 0.94);
  border-bottom: 1px solid var(--border-default);
  backdrop-filter: blur(14px);
}

.brand {
  display: flex;
  align-items: center;
  gap: var(--space-3);
}

.brand-mark {
  width: 44px;
  height: 44px;
}

.brand-text {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.brand-title {
  font-family: var(--font-display);
  font-size: 1.4rem;
  letter-spacing: 0.04em;
}

.brand-subtitle {
  font-size: 0.85rem;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 0.18em;
}

.topbar-center {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: var(--space-4);
  flex-wrap: wrap;
}

.status-chip {
  display: inline-flex;
  align-items: center;
  gap: var(--space-2);
  padding: 6px 12px;
  border-radius: var(--radius-round);
  border: 1px solid var(--border-default);
  color: var(--text-secondary);
  background: var(--surface-1);
}

.status-chip.loading {
  border-color: rgba(212, 154, 79, 0.6);
  color: var(--warning);
}

.status-chip.error {
  border-color: rgba(176, 75, 61, 0.7);
  color: var(--danger);
}

.status-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: var(--accent-2);
}

.status-chip.loading .status-dot {
  background: var(--warning);
}

.status-chip.error .status-dot {
  background: var(--danger);
}

.topbar-actions {
  display: flex;
  gap: var(--space-2);
}

.ghost-btn {
  background: transparent;
  border: 1px solid var(--border-default);
  color: var(--text-secondary);
  padding: 6px 12px;
  border-radius: var(--radius-2);
  cursor: pointer;
  font-weight: 600;
  transition: border-color 0.2s ease, color 0.2s ease;
}

.ghost-btn:hover {
  border-color: var(--accent);
  color: var(--text-primary);
}

.main-nav {
  display: flex;
  gap: var(--space-2);
  background: var(--surface-2);
  padding: var(--space-1);
  border-radius: var(--radius-round);
  border: 1px solid var(--border-default);
}

.main-nav button {
  background-color: transparent;
  border: none;
  color: var(--text-secondary);
  padding: 8px 16px;
  cursor: pointer;
  font-size: 0.95rem;
  font-weight: 600;
  border-radius: var(--radius-round);
  transition: all 0.2s;
}

.main-nav button:hover {
  color: var(--text-primary);
  background-color: var(--surface-3);
}

.main-nav button.active {
  color: #11130f;
  background-color: var(--accent);
}

.content-area {
  flex: 1;
  overflow: hidden;
  position: relative;
  padding: var(--space-5);
}

.loading-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(8, 7, 6, 0.65);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2000;
}

.loading-card {
  background: var(--surface-2);
  padding: var(--space-4) var(--space-5);
  border-radius: var(--radius-3);
  border: 1px solid var(--border-default);
  color: var(--text-primary);
  box-shadow: var(--shadow-1);
}

@media (max-width: 960px) {
  .topbar {
    grid-template-columns: 1fr;
    justify-items: stretch;
  }

  .topbar-center {
    justify-content: space-between;
  }

  .main-nav {
    justify-content: space-between;
  }
}
</style>

================
File: src/store/index.ts
================
import { reactive } from 'vue'
import { api, type ApiPort, type ApiDevice, type ApiPatchbayPoint } from '@/lib/api'
import { strings } from '@/ui/strings'

// Types
export interface PatchBayNode {
  id: number;
  name: string;
  description: string;
  type: string;
}

export interface DevicePort {
  id: string;
  label: string;
  type: 'Input' | 'Output' | 'Other';
  patchbayId: number | null;
}

export interface Device {
  id: number;
  name: string;
  type: string;
  ports: DevicePort[];
  imageUrl?: string | null;
  imageUpdatedAt?: string | null;
}

interface PendingLink {
  portId: string;
  deviceId: number;
  deviceName: string;
  portLabel: string;
}

interface LinkFlow {
  returnTab: 'devices' | 'connections' | 'patchbay';
  returnPayload?: Record<string, unknown>;
}

export interface Toast {
  id: string;
  type: 'success' | 'error' | 'info';
  message: string;
}

// Convert API types (snake_case) to frontend types (camelCase)
function apiPortToDevicePort(apiPort: ApiPort): DevicePort {
  return {
    id: apiPort.id,
    label: apiPort.label,
    type: apiPort.type,
    patchbayId: apiPort.patchbay_id,
  }
}

function apiDeviceToDevice(apiDevice: ApiDevice): Device {
  return {
    id: apiDevice.id,
    name: apiDevice.name,
    type: apiDevice.type,
    ports: apiDevice.ports.map(apiPortToDevicePort),
    imageUrl: apiDevice.image_url,
    imageUpdatedAt: apiDevice.image_updated_at,
  }
}

function apiPatchbayToNode(apiPoint: ApiPatchbayPoint): PatchBayNode {
  return {
    id: apiPoint.id,
    name: apiPoint.name,
    description: apiPoint.description,
    type: apiPoint.type,
  }
}

export const store = reactive({
  patchbayNodes: [] as PatchBayNode[],
  devices: [] as Device[],
  selectedDevice: null as Device | null,
  loading: false,
  error: null as string | null,
  activeTab: 'devices', // 'patchbay' | 'devices' | 'connections'
  selectionMode: false,
  pendingLink: null as PendingLink | null, // The port waiting to be linked (from Device -> Patchbay flow)
  linkFlow: null as LinkFlow | null,
  lastLinkReturnPayload: null as LinkFlow['returnPayload'] | null,
  highlightedPatchIds: [] as number[], // For connection finder highlighting
  patchbayFocusId: null as number | null,
  connectionFinderState: {
    a: null as null | { deviceId: number; portId: string },
    b: null as null | { deviceId: number; portId: string },
  },
  toasts: [] as Toast[],
  
  // Load data from API
  async loadData() {
    this.loading = true
    this.error = null
    
    try {
      const state = await api.getState()
      this.patchbayNodes = state.patchbay_points.map(apiPatchbayToNode)
      this.devices = state.devices.map(apiDeviceToDevice)
    } catch (err: any) {
      this.error = err.message || strings.toast.loadFailed
      this.pushToast({ type: 'error', message: this.error || strings.toast.loadFailed })
      console.error('Error loading data:', err)
    } finally {
      this.loading = false
    }
  },
  
  // Actions
  setTab(tab: string) {
    this.activeTab = tab
  },
  
  // Flow: Device -> Patchbay (Select a slot for a specific port)
  startLinkingPort(payload: PendingLink, options?: Partial<LinkFlow>) {
    this.pendingLink = payload
    this.selectionMode = true
    this.activeTab = 'patchbay'
    this.linkFlow = {
      returnTab: options?.returnTab ?? 'devices',
      returnPayload: options?.returnPayload,
    }
  },
  
  async completeLink(patchbayId: number) {
    if (!this.pendingLink) return

    try {
      const response = await api.linkPort(this.pendingLink.portId, patchbayId)
      
      // Update local state: unlink old port if any
      if (response.unlinked_port_id) {
        for (const device of this.devices) {
          const oldPort = device.ports.find(p => p.id === response.unlinked_port_id)
          if (oldPort) {
            oldPort.patchbayId = null
            break
          }
        }
      }

      // Update linked port
      for (const device of this.devices) {
        const port = device.ports.find(p => p.id === this.pendingLink?.portId)
        if (port && response.patchbay_id !== null) {
          port.patchbayId = response.patchbay_id
          break
        }
      }
      this.pushToast({
        type: 'success',
        message: strings.toast.linkedSuccess(
          this.pendingLink.deviceName,
          this.pendingLink.portLabel,
          response.patchbay_id ?? 0
        ),
      })
    } catch (err: any) {
      console.error('Error linking port:', err)
      this.pushToast({ type: 'error', message: err.message || strings.toast.linkFailed })
      return
    }
    
    this.activeTab = this.linkFlow?.returnTab ?? 'devices'
    this.lastLinkReturnPayload = this.linkFlow?.returnPayload ?? null
    this.cancelLinking()
  },
  
  cancelLinking() {
    this.pendingLink = null
    this.selectionMode = false
    this.linkFlow = null
  },
  
  // Flow: Patchbay -> Device (Unlink or Link via Search)
  async unlinkPort(deviceId: number, portId: string) {
    try {
      await api.unlinkPort(portId)
      
      const device = this.devices.find(d => d.id === deviceId)
      if (device) {
        const port = device.ports.find(p => p.id === portId)
        if (port) port.patchbayId = null
      }
    } catch (err: any) {
      console.error('Error unlinking port:', err)
      this.pushToast({ type: 'error', message: err.message || strings.toast.unlinkFailed })
    }
  },

  // Link a specific port to a patchbay ID (used from the Patchbay search modal)
  async linkPatchbayToDevice(patchbayId: number, deviceId: number, portId: string) {
    try {
      const response = await api.linkPort(portId, patchbayId)
      
      // Update local state: unlink old port if any
      if (response.unlinked_port_id) {
        for (const device of this.devices) {
          const oldPort = device.ports.find(p => p.id === response.unlinked_port_id)
          if (oldPort) {
            oldPort.patchbayId = null
            break
          }
        }
      }

      // Update linked port
      const device = this.devices.find(d => d.id === deviceId)
      if (device) {
        const port = device.ports.find(p => p.id === portId)
        if (port && response.patchbay_id !== null) {
          port.patchbayId = response.patchbay_id
        }
      }
      return true
    } catch (err: any) {
      console.error('Error linking patchbay to device:', err)
      this.pushToast({ type: 'error', message: err.message || strings.toast.linkFailed })
      return false
    }
  },
  
  async addDevice(device: Omit<Device, 'id'>): Promise<Device> {
    try {
      const apiDevice = await api.createDevice({
        name: device.name,
        type: device.type,
        ports: device.ports.map(p => ({
          label: p.label,
          type: p.type,
          patchbay_id: p.patchbayId,
        })),
      })
      
      const newDevice = apiDeviceToDevice(apiDevice)
      this.devices.push(newDevice)
      return newDevice
    } catch (err: any) {
      console.error('Error adding device:', err)
      throw err
    }
  },

  async updateDevice(id: number, payload: { name: string; type: string; ports: DevicePort[] }): Promise<Device> {
    try {
      const apiDevice = await api.updateDevice(id, {
        name: payload.name,
        type: payload.type,
        ports: payload.ports.map(p => ({
          id: p.id || undefined,
          label: p.label,
          type: p.type,
          patchbay_id: p.patchbayId ?? null,
        })),
      })

      const updatedDevice = apiDeviceToDevice(apiDevice)
      const index = this.devices.findIndex(d => d.id === id)
      if (index !== -1) {
        this.devices[index] = updatedDevice
      }
      return updatedDevice
    } catch (err: any) {
      console.error('Error updating device:', err)
      throw err
    }
  },
  
  async deleteDevice(id: number) {
    try {
      await api.deleteDevice(id)
      
      const index = this.devices.findIndex(d => d.id === id)
      if (index !== -1) this.devices.splice(index, 1)
      
      // Clear selection if deleted device was selected
      if (this.selectedDevice?.id === id) {
        this.selectedDevice = null
      }
    } catch (err: any) {
      console.error('Error deleting device:', err)
      throw err
    }
  },

  async uploadDeviceImage(deviceId: number, image: File): Promise<Device> {
    try {
      const apiDevice = await api.uploadDeviceImage(deviceId, image)
      const updatedDevice = apiDeviceToDevice(apiDevice)
      
      // Replace device in store
      const index = this.devices.findIndex(d => d.id === deviceId)
      if (index !== -1) {
        this.devices[index] = updatedDevice
      }
      
      // Update selectedDevice reference if it's the same device
      if (this.selectedDevice?.id === deviceId) {
        this.selectedDevice = updatedDevice
      }
      
      return updatedDevice
    } catch (err: any) {
      console.error('Error uploading device image:', err)
      throw err
    }
  },

  setConnectionFinderSelection(side: 'a' | 'b', deviceId: number, portId: string) {
    this.connectionFinderState[side] = { deviceId, portId }
  },

  clearConnectionFinderSelection(side: 'a' | 'b') {
    this.connectionFinderState[side] = null
  },

  swapConnectionFinderSelections() {
    const temp = this.connectionFinderState.a
    this.connectionFinderState.a = this.connectionFinderState.b
    this.connectionFinderState.b = temp
  },

  clearLinkReturnPayload() {
    this.lastLinkReturnPayload = null
  },

  pushToast(payload: Omit<Toast, 'id'>) {
    const id = `${Date.now()}-${Math.random().toString(16).slice(2)}`
    const toast: Toast = { id, ...payload }
    this.toasts.push(toast)
    window.setTimeout(() => this.dismissToast(id), 4200)
  },

  dismissToast(id: string) {
    const index = this.toasts.findIndex(toast => toast.id === id)
    if (index !== -1) this.toasts.splice(index, 1)
  },
  
  // Helpers
  getDeviceByPatchbayId(patchbayId: number) {
    for (const device of this.devices) {
      const port = device.ports.find(p => p.patchbayId === patchbayId)
      if (port) return { device, port }
    }
    return null
  }
})

================
File: .github/workflows/main.yml
================
name: CD - Deploy

on:
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest

    env:
      REMOTE_PATH: ${{ secrets.REMOTE_PATH }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Preparar clave SSH
        run: |
          mkdir -p ~/.ssh
          echo "$PI_SSH_PRIVATE_KEY" > key.pem
          chmod 600 key.pem
        env:
          PI_SSH_PRIVATE_KEY: ${{ secrets.PI_SSH_PRIVATE_KEY }}

      - name: Pull y desplegar con Docker Compose en el VPS
        run: |
          ssh -o StrictHostKeyChecking=no -i key.pem -p "$PI_SSH_PORT" "$PI_USER@$PI_HOST" \
                "REMOTE_PATH='${REMOTE_PATH}' bash -s" <<'EOF'
          set -e
          echo "Conectado al VPS"
          cd "$REMOTE_PATH"
          echo "Directorio actual de trabajo: $(pwd)"

          echo "Haciendo git pull..."
          git pull origin main

          echo "Deteniendo contenedores..."
          docker compose down || true

          echo "Levantando con build..."
          docker compose up -d --build

          echo "Limpieza de im√°genes no utilizadas..."
          docker image prune -f || true

          echo "‚úÖ Despliegue completado."
          EOF

        env:
          PI_HOST: ${{ secrets.PI_HOST }}
          PI_USER: ${{ secrets.PI_USER }}
          PI_SSH_PORT: ${{ secrets.PI_SSH_PORT }}
          REMOTE_PATH: ${{ env.REMOTE_PATH }}

      - name: Limpiar clave local
        if: always()
        run: rm -f key.pem





================================================================
End of Codebase
================================================================

================
File: IMPLEMENTATION_SUMMARY.md
================
# üéâ Implementaci√≥n de Clerk - Resumen Ejecutivo

## ‚úÖ Estado: COMPLETADO

La integraci√≥n de autenticaci√≥n con Clerk ha sido implementada exitosamente siguiendo el plan de implementaci√≥n.

## üì¶ Archivos creados/modificados

### Nuevos archivos
- `src/lib/authToken.ts` - Gesti√≥n centralizada de tokens
- `src/components/AuthScreen.vue` - Pantalla de login/signup
- `CLERK_IMPLEMENTATION.md` - Documentaci√≥n t√©cnica completa
- `TESTING_CLERK.md` - Plan de pruebas y troubleshooting
- `scripts/verify-clerk-setup.sh` - Script de validaci√≥n
- `.env.example` - Template de variables de entorno

### Archivos modificados
- `package.json` - Agregada dependencia `@clerk/vue`
- `src/main.ts` - Inicializaci√≥n de Clerk
- `src/App.vue` - UI con SignedIn/SignedOut + UserButton
- `src/lib/api.ts` - Inyecci√≥n de Authorization header + retry 401
- `src/store/index.ts` - Flag de carga + manejo de errores auth
- `src/ui/strings.ts` - Mensajes de error de autenticaci√≥n

## üéØ Funcionalidades implementadas

‚úÖ **Autenticaci√≥n completa:**
- Login/Signup con Google (y otros providers disponibles en Clerk)
- Pantalla dedicada de autenticaci√≥n
- UserButton para logout y gesti√≥n de cuenta

‚úÖ **Seguridad:**
- Tokens JWT autom√°ticos (no se guardan en localStorage)
- Header `Authorization: Bearer <token>` en todas las requests
- Retry autom√°tico ante 401
- Manejo de errores 401/403 con UX clara

‚úÖ **Gesti√≥n de estado:**
- No carga datos hasta que el usuario est√© autenticado
- Carga autom√°tica al hacer login (una sola vez)
- Flag `hasLoadedInitialData` previene cargas duplicadas

‚úÖ **UX mejorada:**
- Loading state mientras Clerk inicializa
- Mensajes de error espec√≠ficos para auth
- Dise√±o coherente con la app principal

## üöÄ Pr√≥ximo paso: Probar

```bash
# Verificar configuraci√≥n
./scripts/verify-clerk-setup.sh

# Iniciar dev server
npm run dev

# Abrir en navegador (modo inc√≥gnito recomendado)
# http://localhost:5173
```

Ver `TESTING_CLERK.md` para plan de pruebas completo.

## üìã Checklist para producci√≥n

- [ ] Obtener Clerk production keys
- [ ] Setear `VITE_CLERK_PUBLISHABLE_KEY` en plataforma de deploy
- [ ] Configurar allowed URLs en Clerk Dashboard (producci√≥n)
- [ ] Implementar validaci√≥n de tokens en el backend
- [ ] Asociar datos con `user_id` en base de datos
- [ ] Verificar CORS entre frontend y backend
- [ ] Testing end-to-end en staging

## üîÆ Opcional: Multi-tenant (Organizations)

Si quer√©s soportar m√∫ltiples studios/workspaces:

1. Habilitar Organizations en Clerk Dashboard
2. Agregar `OrganizationSwitcher` en la UI
3. Enviar `X-Workspace-Id` header en requests
4. Actualizar backend para filtrar por workspace

Ver secci√≥n correspondiente en `CLERK_IMPLEMENTATION.md`.

## üìû Soporte

- [Clerk Docs](https://clerk.com/docs)
- [Clerk Dashboard](https://dashboard.clerk.com)
- [Discord de Clerk](https://clerk.com/discord)

---

**Build status:** ‚úÖ Compilaci√≥n exitosa  
**TypeScript:** ‚úÖ Sin errores  
**Dependencias:** ‚úÖ Instaladas  
**Configuraci√≥n:** ‚úÖ Validada  

¬°Listo para testear! üéâ

================
File: TESTING_CLERK.md
================
# üéØ Testing de Integraci√≥n Clerk

## Pre-requisitos completados ‚úÖ
- `@clerk/vue` instalado
- Variables de entorno configuradas en `.env`
- C√≥digo de integraci√≥n implementado

## üß™ Plan de pruebas

### 1. Verificar configuraci√≥n de Clerk Dashboard

Antes de probar, asegurate de que en [Clerk Dashboard](https://dashboard.clerk.com):

1. **OAuth Providers habilitado:**
   - Ve a "User & Authentication" ‚Üí "Social Connections"
   - Activa "Google" (o el provider que quieras usar)

2. **URLs permitidas (desarrollo):**
   - Ve a "Paths"
   - Agrega `http://localhost:5173` (o el puerto de tu dev server)

### 2. Iniciar el servidor de desarrollo

```bash
npm run dev
```

### 3. Test 1: Usuario no autenticado

**Resultado esperado:**
- ‚úÖ Se muestra AuthScreen (pantalla de login)
- ‚úÖ NO aparece la app principal
- ‚úÖ En DevTools ‚Üí Network: NO hay requests a `/state` o tu API

**C√≥mo verificar:**
1. Abrir en modo inc√≥gnito o borrar cookies
2. Ir a `http://localhost:5173`
3. Confirmar que ves el componente de login de Clerk

### 4. Test 2: Login con Google

**Resultado esperado:**
- ‚úÖ Click en "Continue with Google" funciona
- ‚úÖ Despu√©s de autenticarse, se muestra la app completa
- ‚úÖ Se ejecuta autom√°ticamente `store.loadData()`
- ‚úÖ En Network: aparece request a `/state` con header `Authorization: Bearer <token>`

**C√≥mo verificar:**
1. Abrir DevTools ‚Üí Network tab
2. Hacer login
3. Buscar la request a `/state`
4. Click en la request ‚Üí Headers ‚Üí Request Headers
5. Confirmar que existe: `Authorization: Bearer ey...`

### 5. Test 3: Navegaci√≥n normal

**Resultado esperado:**
- ‚úÖ Todas las requests a la API incluyen el token
- ‚úÖ UserButton aparece arriba a la derecha
- ‚úÖ La app funciona normalmente (crear devices, links, etc.)

**C√≥mo verificar:**
1. Crear un device
2. Linkear un port
3. Cambiar entre tabs
4. En Network, verificar que todas las requests tengan Authorization header

### 6. Test 4: Logout

**Resultado esperado:**
- ‚úÖ Click en UserButton ‚Üí "Sign out"
- ‚úÖ Vuelve a AuthScreen
- ‚úÖ NO hay requests a la API despu√©s del logout

**C√≥mo verificar:**
1. Click en el avatar/UserButton (arriba derecha)
2. Click en "Sign out"
3. Confirmar que vuelve a la pantalla de login
4. Confirmar en Network que no hay nuevos requests

### 7. Test 5: Reintento ante 401

**Resultado esperado:**
- ‚úÖ Si el backend devuelve 401, se reintenta una vez con token fresco
- ‚úÖ Se muestra mensaje de error apropiado si falla

**C√≥mo simular:**
- Opci√≥n A: Modificar temporalmente tu backend para devolver 401
- Opci√≥n B: Usar DevTools para bloquear requests

### 8. Test 6: Refresh de p√°gina

**Resultado esperado:**
- ‚úÖ Al recargar la p√°gina, mantiene la sesi√≥n
- ‚úÖ Carga los datos autom√°ticamente
- ‚úÖ NO pide login nuevamente

**C√≥mo verificar:**
1. Estando logueado, presiona F5 o Ctrl+R
2. La app debe volver a cargar directamente (sin login)
3. Los datos se cargan autom√°ticamente

## üêõ Problemas comunes

### "Clerk no est√° cargando"
- Verificar que `VITE_CLERK_PUBLISHABLE_KEY` est√© en `.env`
- Verificar que la key empiece con `pk_test_` o `pk_live_`
- Reiniciar el dev server despu√©s de cambiar `.env`

### "No puedo loguearme con Google"
- Ir a Clerk Dashboard ‚Üí Social Connections
- Verificar que Google OAuth est√© habilitado
- Verificar que la URL de desarrollo est√© en las allowed URLs

### "401 Unauthorized en todas las requests"
- Verificar que tu backend est√© validando tokens de Clerk
- Verificar que el backend acepte el header `Authorization: Bearer ...`
- Ver la consola del navegador por errores de CORS

### "El token no se est√° enviando"
- Abrir consola y buscar: `[authToken] Token getter not registered`
- Verificar que `isSignedIn` sea `true`
- Verificar que `getToken.value` no sea `null`

## ‚úÖ Checklist final

- [ ] La app muestra login cuando no hay sesi√≥n
- [ ] Login con Google funciona
- [ ] La app principal se muestra despu√©s del login
- [ ] `store.loadData()` se ejecuta autom√°ticamente (una sola vez)
- [ ] Todas las requests tienen header `Authorization: Bearer ...`
- [ ] UserButton funciona y permite logout
- [ ] Logout vuelve a la pantalla de login
- [ ] Refresh mantiene la sesi√≥n
- [ ] No hay errores en consola
- [ ] Build de producci√≥n funciona: `npm run build`

## üìù Siguiente paso: Backend

Una vez que el frontend funciona, necesit√°s:

1. **Validar tokens en tu backend:**
   - Instalar SDK de Clerk para tu lenguaje backend
   - Validar el JWT en cada request protegido
   - Extraer el `userId` del token

2. **Asociar datos con usuarios:**
   - Modificar tu schema para incluir `user_id` o `clerk_user_id`
   - Filtrar queries por usuario actual
   - Verificar permisos antes de modificar datos

Ver `CLERK_IMPLEMENTATION.md` para m√°s detalles.

================
File: public/vite.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>

================
File: src/assets/cat.svg
================
<?xml version="1.0" encoding="utf-8"?>

<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
<svg height="800px" width="800px" version="1.1" id="_x32_" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" 
	 viewBox="0 0 512 512"  xml:space="preserve">
<style type="text/css">
	.st0{fill:#000000;}
</style>
<g>
	<path class="st0" d="M504.302,195.59c-10.618-6.362-29.71-43.514-33.959-47.755c-4.249-4.256-28.662-13.81-28.662-13.81
		l-13.795-43.514c-26.542,3.185-42.449,45.634-43.513,48.819c0,0-2.661,73.764-120.47,45.11
		c-84.437-20.54-135.22-40.407-177.872-0.36c-2.668-4.578-4.491-9.234-5.822-14.257c-2.378-9.062-2.918-19.46-2.91-31.308
		c0-5.806,0.109-11.924,0.117-18.34c-0.008-13.436-0.493-28.248-4.046-44.015C69.85,60.386,63.136,43.743,51.344,27.162
		c-5.086-7.168-15.024-8.858-22.199-3.764c-7.167,5.094-8.858,15.031-3.764,22.199c9.304,13.145,14.162,25.368,16.932,37.551
		c2.739,12.167,3.271,24.397,3.264,37.027c0,6.024-0.118,12.136-0.118,18.34c0.016,12.646,0.438,25.799,3.928,39.32
		c2.746,10.735,7.722,21.58,15.508,31.706C31.93,261.458,50.037,316.584,50.037,316.584l-34.093,54.241
		c-0.618,0.978-1.033,2.066-1.244,3.192L0.146,454.073c-0.641,3.521,0.862,7.08,3.819,9.084l40.979,27.763
		c0.876,0.602,1.964,0.775,2.981,0.493c1.026-0.274,1.863-0.994,2.308-1.949l8.326-17.825c0.618-1.338,0.368-2.918-0.634-3.998
		l-10.728-11.448c-2.182-2.324-2.973-5.634-2.081-8.701l17.84-61.033c0.579-1.948,1.784-3.646,3.435-4.82l23.983-17.058
		c3.255-2.332,7.66-2.222,10.806,0.251c3.146,2.472,4.288,6.721,2.809,10.438L93.41,401.858c-1.22,3.051-0.681,6.525,1.401,9.06
		l60.298,73.365h45.218c1.996,0,3.616-1.62,3.616-3.607v-22.504c0-1.996-1.62-3.615-3.616-3.615h-14.303
		c-3.342,0-6.409-1.854-7.982-4.804l-24.484-41.049c-1.643-3.106-1.33-6.87,0.783-9.663l21.948-28.999
		c1.706-2.245,4.367-3.575,7.192-3.575h61.197c2.872,0,5.579,1.376,7.277,3.701c1.698,2.324,2.191,5.313,1.33,8.059l-19.726,62.16
		c-0.626,1.957-0.564,4.077,0.18,5.994l12.653,32.598h39.272v-8.49l-6.494-20.415c-0.61-1.909-0.563-3.967,0.133-5.852
		l26.471-71.847c1.315-3.553,4.694-5.908,8.474-5.908h27.011c2.449,0,4.796,1.002,6.502,2.777l74.813,103.365c0,0,38.208,0,50.947,0
		c12.738,0,7.809-25.414-4.241-26.542c-22.826-2.12-52.004-65.798-64.742-88.09c-12.739-22.285,24.664-91.299,53.067-94.453
		c28.654-3.185,43.514-14.867,47.763-30.79C513.856,223.187,514.92,201.959,504.302,195.59z"/>
</g>
</svg>

================
File: src/assets/el-riche-mark.svg
================
<svg width="120" height="120" viewBox="0 0 120 120" fill="none" xmlns="http://www.w3.org/2000/svg">
  <rect x="8" y="8" width="104" height="104" rx="20" stroke="#8FC09B" stroke-width="6" />
  <circle cx="60" cy="60" r="26" stroke="#8FC09B" stroke-width="6" />
  <path d="M34 36H86" stroke="#8FC09B" stroke-width="6" stroke-linecap="round" />
  <path d="M34 84H86" stroke="#8FC09B" stroke-width="6" stroke-linecap="round" />
</svg>

================
File: src/ui/ConfirmDialog.vue
================
<script setup lang="ts">
import { strings } from './strings'

const t = strings

defineProps<{ title: string; message: string; confirmLabel?: string; cancelLabel?: string }>()

defineEmits<{ confirm: []; cancel: [] }>()
</script>

<template>
  <div class="confirm-overlay" role="dialog" aria-modal="true">
    <div class="confirm-card">
      <h3>{{ title }}</h3>
      <p>{{ message }}</p>
      <div class="confirm-actions">
        <button class="btn ghost" @click="$emit('cancel')">
          {{ cancelLabel || t.confirm.cancel }}
        </button>
        <button class="btn solid" @click="$emit('confirm')">
          {{ confirmLabel || t.confirm.confirm }}
        </button>
      </div>
    </div>
  </div>
</template>

<style scoped>
.confirm-overlay {
  position: fixed;
  inset: 0;
  background: rgba(9, 8, 6, 0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2500;
}

.confirm-card {
  background: var(--surface-2);
  border: 1px solid var(--border-default);
  border-radius: var(--radius-3);
  padding: var(--space-5);
  max-width: 360px;
  width: calc(100% - 40px);
  box-shadow: var(--shadow-2);
}

.confirm-card h3 {
  margin: 0 0 var(--space-2);
  font-size: 1.4rem;
}

.confirm-card p {
  margin: 0 0 var(--space-4);
  color: var(--text-secondary);
}

.confirm-actions {
  display: flex;
  justify-content: flex-end;
  gap: var(--space-2);
}

.btn {
  border-radius: var(--radius-2);
  border: 1px solid transparent;
  padding: 8px 14px;
  font-weight: 600;
  cursor: pointer;
}

.btn.ghost {
  background: transparent;
  border-color: var(--border-default);
  color: var(--text-secondary);
}

.btn.solid {
  background: var(--accent);
  color: #0d0f0c;
}
</style>

================
File: src/ui/strings.ts
================
export const strings = {
  app: {
    name: 'El Riche Patchbay',
    tagline: 'Studio patchbay control',
    loadingData: 'Loading data...',
    retry: 'Retry',
    syncing: 'Syncing...',
    synced: 'Synced',
    syncIssue: 'Sync issue',
    export: 'Export',
    help: 'Help',
    shortcuts: 'Shortcuts',
    comingSoon: 'Coming soon',
    dismiss: 'Dismiss',
    closeSymbol: 'x',
  },
  nav: {
    patchbay: 'Patchbay',
    devices: 'Devices',
    connections: 'Connections',
  },
  confirm: {
    confirm: 'Confirm',
    cancel: 'Cancel',
    overwriteTitle: 'Overwrite patch point?',
    overwriteMessage: (deviceName: string, portLabel: string) =>
      `This slot is already connected to ${deviceName} - ${portLabel}. Overwrite it?`,
    deleteDeviceTitle: 'Delete device?',
    deleteDeviceMessage: (deviceName: string) =>
      `Delete ${deviceName}? This cannot be undone.`,
  },
  toast: {
    linkedSuccess: (deviceName: string, portLabel: string, patchbayId: number) =>
      `Linked ${deviceName} ${portLabel} -> Patch #${patchbayId}.`,
    linkFailed: 'Linking failed. Please try again.',
    unlinkFailed: 'Unlink failed. Please try again.',
    loadFailed: 'Failed to load data. Please retry.',
    deviceSaved: 'Device saved.',
    deviceDeleted: 'Device deleted.',
    deviceSaveFailed: 'Failed to save device.',
    deviceDeleteFailed: 'Failed to delete device.',
    imageParseFailed: 'Image parsing failed. Try a clearer, well-lit photo.',
    sessionExpired: 'Sesi√≥n expirada. Por favor, volv√© a iniciar sesi√≥n.',
    noPermission: 'No ten√©s permisos para acceder a estos datos.',
  },
  patchbay: {
    linkingBanner: (deviceName: string, portLabel: string) =>
      `Select a patch point for: ${deviceName} - ${portLabel}.`,
    linkingFallback: 'Select a patch point to link.',
    cancel: 'Cancel',
    showingConnection: (left: number, right: number) =>
      `Showing connection: #${left} <-> #${right}`,
    clearHighlights: 'Clear',
    searchPlaceholder: 'Search patchbay (point or device)...',
    patchPointTitle: (id: number) => `Patch Point #${id}`,
    nameLabel: 'Name',
    descriptionLabel: 'Description',
    typeLabel: 'Type',
    connectionLabel: 'Connection',
    connectedTo: 'Connected to',
    portLabel: 'Port',
    unlink: 'Unlink',
    notConnected: 'Not connected',
    linkDevice: 'Link device',
    close: 'Close',
    linkDeviceTitle: (id: number) => `Link device to point #${id}`,
    searchDevicesPlaceholder: 'Search devices...',
    occupiedTag: (id: number) => `(#${id})`,
    tooltip: (deviceName: string, portLabel: string) => `${deviceName} - ${portLabel}`,
    legendTitle: 'Legend',
    legendLinked: 'Linked',
    legendOpen: 'Open',
    legendMatch: 'Search match',
    legendHighlight: 'Highlighted',
    rowLabels: ['A', 'B'],
    rowLabel: (label: string) => `Row ${label}`,
    columnLabel: (label: number) => `Col ${label}`,
    linkDeviceAction: 'Link to device',
  },
  devices: {
    title: 'Devices',
    searchPlaceholder: 'Search devices...',
    addDevice: 'Add Device',
    portsCount: (count: number) => `${count} Ports`,
    typeLabel: 'Type',
    idLabel: 'ID',
    portsConfig: 'Ports Configuration',
    linkedTo: (patchbayId: number) => `Linked to #${patchbayId}`,
    goToPatch: (patchbayId: number) => `Go to patch #${patchbayId}`,
    unlink: 'Unlink',
    notConnected: 'Not connected',
    link: 'Link',
    deleteDevice: 'Delete Device',
    closeDetail: 'Close',
    editDevice: 'Edit Device',
    addNewDevice: 'Add New Device',
    tabManual: 'Manual',
    tabAutoDetect: 'Auto-detect',
    nameLabel: 'Name',
    namePlaceholder: 'Device name',
    typePlaceholder: 'Select type',
    portsLabel: 'Ports',
    addPort: '+ Add Port',
    portNamePlaceholder: 'Port name',
    removePort: 'Remove',
    noPorts: 'No ports added yet.',
    resetForm: 'Reset Form',
    updateDevice: 'Update Device',
    createDevice: 'Create Device',
    aiHelp: 'Upload a device photo; we will detect ports and create a draft.',
    aiUpload: 'Upload or take photo',
    aiProcessing: 'Analyzing image...',
    aiDraftReady: 'Draft ready. Review and edit before saving.',
    aiReviewDraft: 'Review draft',
    aiSteps: {
      upload: '1 Upload',
      processing: '2 Processing',
      review: '3 Review',
    },
    addPortLabel: (index: number) => `Port ${index}`,
    validation: {
      addPortFirst: 'Add at least one port.',
      nameRequired: 'Device name is required.',
    },
    saving: 'Saving...',
    portTypes: {
      Input: 'Input',
      Output: 'Output',
      Other: 'Other',
    },
    deviceTypes: ['Preamp', 'Compressor', 'EQ', 'Interface', 'Console', 'Other'],
  },
  connections: {
    title: 'Connection Finder',
    subtitle: 'Select two device ports to see which patch points to cable.',
    origin: 'Origin',
    destination: 'Destination',
    sideALabel: 'A',
    sideBLabel: 'B',
    searchPlaceholder: 'Search device or port...',
    unlinked: 'Unlinked',
    noResults: 'No results found',
    patchbayLabel: 'Patchbay',
    notLinkedWarning: 'Not linked to patchbay',
    swapTitle: 'Swap',
    clearSelection: 'Clear selection',
    swapLabel: 'Swap',
    resultSuccessTitle: 'Connection found',
    resultErrorTitle: 'Cannot connect',
    successBadge: 'OK',
    errorBadge: 'NO',
    cableLabel: 'Cable',
    resultInstruction: (a: number, b: number) =>
      `Connect patch #${a} (source) to patch #${b} (destination).`,
    goToPatchbay: 'View highlighted patch points',
    linkNow: 'Link this port now',
    linkNowFor: (label: string) => `Link ${label}`,
    copyInstruction: 'Copy instruction',
    copySuccess: 'Instruction copied.',
    copyFailed: 'Copy failed. Please try again.',
    linkReturnHint: 'Port linked. Continue to get patch instructions.',
    linkRequiredTitle: 'Link required',
    linkRequiredHint: 'Map the missing port to a patch point to get the instruction.',
    pickPatchPoint: 'Select patch point',
    mapPort: 'Map port',
    patchPointOption: (id: number, name: string) => `#${id} - ${name}`,
    hint: 'Link ports to patch points from the Devices tab first.',
    emptyTitle: 'Pick a source and destination port to see the cable path.',
    emptyIcon: '...',
    errorBothUnlinked: 'Neither port is linked to the patchbay.',
    errorUnlinked: (label: string) => `${label} is not linked to the patchbay.`,
  },
}

export type Strings = typeof strings

================
File: src/ui/ToastHost.vue
================
<script setup lang="ts">
import { store } from '../store'
import { strings } from './strings'

const t = strings

const dismiss = (id: string) => {
  store.dismissToast(id)
}
</script>

<template>
  <div class="toast-host" aria-live="polite">
    <div
      v-for="toast in store.toasts"
      :key="toast.id"
      class="toast"
      :class="`toast-${toast.type}`"
      role="status"
    >
      <div class="toast-message">{{ toast.message }}</div>
      <button class="toast-close" :aria-label="t.app.dismiss" @click="dismiss(toast.id)">
        {{ t.app.closeSymbol }}
      </button>
    </div>
  </div>
</template>

<style scoped>
.toast-host {
  position: fixed;
  top: var(--space-6);
  right: var(--space-6);
  display: flex;
  flex-direction: column;
  gap: var(--space-3);
  z-index: 3000;
}

.toast {
  min-width: 240px;
  max-width: 320px;
  background: var(--surface-2);
  color: var(--text-primary);
  border-radius: var(--radius-3);
  border: 1px solid var(--border-default);
  padding: var(--space-3) var(--space-3);
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  gap: var(--space-2);
  box-shadow: var(--shadow-1);
  animation: toast-in 0.25s ease-out;
}

.toast-message {
  font-size: 0.95rem;
  line-height: 1.4;
}

.toast-close {
  background: transparent;
  border: none;
  color: var(--text-muted);
  cursor: pointer;
  font-size: 1.1rem;
  line-height: 1;
  padding: 0;
}

.toast-success {
  border-color: rgba(106, 163, 111, 0.7);
}

.toast-error {
  border-color: rgba(176, 75, 61, 0.7);
}

.toast-info {
  border-color: rgba(143, 192, 155, 0.6);
}

@keyframes toast-in {
  from {
    opacity: 0;
    transform: translateY(-6px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

@media (max-width: 720px) {
  .toast-host {
    right: var(--space-4);
    left: var(--space-4);
  }

  .toast {
    max-width: none;
  }
}
</style>

================
File: .dockerignore
================
.git
node_modules
.gitignore
Dockerfile
.github
*.log

================
File: .env.example
================
VITE_API_URL=http://localhost:8088

================
File: tsconfig.json
================
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}

================
File: src/main.ts
================
import { createApp } from 'vue'
import { clerkPlugin } from '@clerk/vue'
import './style.css'
import App from './App.vue'

// Validar que la env var de Clerk est√© presente
const clerkPubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY
if (!clerkPubKey) {
  console.error(
    '‚ùå VITE_CLERK_PUBLISHABLE_KEY no est√° configurada.\n' +
    'Verific√° que exista en .env y que empiece con "pk_"'
  )
}

const app = createApp(App)

// Inicializar Clerk
if (clerkPubKey) {
  app.use(clerkPlugin, {
    publishableKey: clerkPubKey
  })
}

app.mount('#app')

================
File: .gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Environment variables
.env
.env.local
.env.*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

================
File: tsconfig.node.json
================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "types": ["node"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}

================
File: vite.config.ts
================
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import { fileURLToPath, URL } from 'node:url'

// https://vite.dev/config/
export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: {
      '@': fileURLToPath(new URL('./src', import.meta.url))
    }
  }
})

================
File: src/components/ConnectionFinder.vue
================
<script setup lang="ts">
import { ref, computed, watch } from 'vue'
import { store, type Device, type DevicePort } from '../store'
import { strings } from '../ui/strings'

const t = strings

interface PortSelection {
  device: Device | null
  port: DevicePort | null
}

interface MissingSelection {
  side: 'a' | 'b'
  selection: PortSelection
}

interface ConnectionResultSuccess {
  type: 'success'
  patchA: number
  patchB: number
  deviceA?: string
  portA?: string
  deviceB?: string
  portB?: string
}

interface ConnectionResultError {
  type: 'error'
  message: string
  missing: MissingSelection[]
}

const searchA = ref('')
const searchB = ref('')
const showDropdownA = ref(false)
const showDropdownB = ref(false)
const showReturnHint = ref(false)

const mappingChoice = ref<{ a: number | null; b: number | null }>({ a: null, b: null })

const allPorts = computed(() => {
  const result: { device: Device; port: DevicePort }[] = []
  for (const device of store.devices) {
    for (const port of device.ports) {
      result.push({ device, port })
    }
  }
  return result
})

const filteredPortsA = computed(() => {
  if (!searchA.value) return allPorts.value
  const query = searchA.value.toLowerCase()
  return allPorts.value.filter(item =>
    item.device.name.toLowerCase().includes(query) ||
    item.port.label.toLowerCase().includes(query)
  )
})

const filteredPortsB = computed(() => {
  if (!searchB.value) return allPorts.value
  const query = searchB.value.toLowerCase()
  return allPorts.value.filter(item =>
    item.device.name.toLowerCase().includes(query) ||
    item.port.label.toLowerCase().includes(query)
  )
})

const availablePatchPoints = computed(() => {
  return store.patchbayNodes.filter(node => !store.getDeviceByPatchbayId(node.id))
})

const getSelection = (side: 'a' | 'b'): PortSelection => {
  const state = store.connectionFinderState[side]
  if (!state) return { device: null, port: null }
  const device = store.devices.find(item => item.id === state.deviceId) || null
  if (!device) return { device: null, port: null }
  const port = device.ports.find(item => item.id === state.portId) || null
  if (!port) return { device: null, port: null }
  return { device, port }
}

const selectionA = computed(() => getSelection('a'))
const selectionB = computed(() => getSelection('b'))

const selectPortA = (device: Device, port: DevicePort) => {
  store.setConnectionFinderSelection('a', device.id, port.id)
  showDropdownA.value = false
}

const selectPortB = (device: Device, port: DevicePort) => {
  store.setConnectionFinderSelection('b', device.id, port.id)
  showDropdownB.value = false
}

const clearSelectionA = () => {
  store.clearConnectionFinderSelection('a')
  searchA.value = ''
}

const clearSelectionB = () => {
  store.clearConnectionFinderSelection('b')
  searchB.value = ''
}

watch(selectionA, (value) => {
  if (value.port && value.device) {
    searchA.value = `${value.device.name} - ${value.port.label}`
    mappingChoice.value.a = null
  }
})

watch(selectionB, (value) => {
  if (value.port && value.device) {
    searchB.value = `${value.device.name} - ${value.port.label}`
    mappingChoice.value.b = null
  }
})

const connectionResult = computed<ConnectionResultSuccess | ConnectionResultError | null>(() => {
  const portA = selectionA.value.port
  const portB = selectionB.value.port

  if (!portA || !portB) return null

  const patchA = portA.patchbayId
  const patchB = portB.patchbayId
  const missing: MissingSelection[] = []

  if (!patchA) missing.push({ side: 'a', selection: selectionA.value })
  if (!patchB) missing.push({ side: 'b', selection: selectionB.value })

  if (!patchA && !patchB) {
    return {
      type: 'error',
      message: t.connections.errorBothUnlinked,
      missing,
    }
  }

  if (!patchA) {
    return {
      type: 'error',
      message: t.connections.errorUnlinked(`${selectionA.value.device?.name} - ${portA.label}`),
      missing,
    }
  }

  if (!patchB) {
    return {
      type: 'error',
      message: t.connections.errorUnlinked(`${selectionB.value.device?.name} - ${portB.label}`),
      missing,
    }
  }

  return {
    type: 'success',
    patchA,
    patchB,
    deviceA: selectionA.value.device?.name,
    portA: portA.label,
    deviceB: selectionB.value.device?.name,
    portB: portB.label,
  }
})

const highlightedPatches = computed((): number[] => {
  if (connectionResult.value?.type === 'success') {
    return [connectionResult.value.patchA, connectionResult.value.patchB]
  }
  return []
})

watch(highlightedPatches, (newVal) => {
  store.highlightedPatchIds = newVal
}, { immediate: true })

watch(() => store.activeTab, (tab) => {
  if (tab !== 'connections') return
  const payload = store.lastLinkReturnPayload as { resume?: string; missingSide?: 'a' | 'b' } | null
  if (!payload || payload.resume !== 'connections') return
  showReturnHint.value = true
  store.clearLinkReturnPayload()
})

const dismissReturnHint = () => {
  showReturnHint.value = false
}

const goToPatchbay = () => {
  const focusId = highlightedPatches.value[0]
  store.patchbayFocusId = focusId || null
  store.setTab('patchbay')
}

const swapSelections = () => {
  store.swapConnectionFinderSelections()
}

const linkNow = (missing: MissingSelection) => {
  if (!missing.selection.device || !missing.selection.port) return
  store.startLinkingPort({
    portId: missing.selection.port.id,
    deviceId: missing.selection.device.id,
    deviceName: missing.selection.device.name,
    portLabel: missing.selection.port.label,
  }, {
    returnTab: 'connections',
    returnPayload: { resume: 'connections', missingSide: missing.side },
  })
}

const mapMissingPort = async (missing: MissingSelection) => {
  const patchbayId = mappingChoice.value[missing.side]
  if (!patchbayId) return
  if (!missing.selection.device || !missing.selection.port) return
  try {
    const didLink = await store.linkPatchbayToDevice(
      patchbayId,
      missing.selection.device.id,
      missing.selection.port.id
    )
    if (!didLink) return
    store.pushToast({
      type: 'success',
      message: strings.toast.linkedSuccess(
        missing.selection.device.name,
        missing.selection.port.label,
        patchbayId
      ),
    })
    mappingChoice.value[missing.side] = null
  } catch (err: any) {
    store.pushToast({ type: 'error', message: err?.message || strings.toast.linkFailed })
  }
}

const copyInstruction = async () => {
  if (!connectionResult.value || connectionResult.value.type !== 'success') return
  const text = t.connections.resultInstruction(connectionResult.value.patchA, connectionResult.value.patchB)
  try {
    await navigator.clipboard.writeText(text)
    store.pushToast({ type: 'success', message: t.connections.copySuccess })
  } catch (err) {
    store.pushToast({ type: 'error', message: t.connections.copyFailed })
  }
}
</script>

<template>
  <div class="connection-finder">
    <div class="finder-header">
      <h2>{{ t.connections.title }}</h2>
      <p class="subtitle">{{ t.connections.subtitle }}</p>
    </div>

    <div v-if="showReturnHint" class="return-hint">
      <span>{{ t.connections.linkReturnHint }}</span>
      <button class="ghost-btn" @click="dismissReturnHint">{{ t.app.dismiss }}</button>
    </div>

    <div class="finder-body">
      <div class="selectors-container">
        <div class="selector-box">
          <label class="selector-label">
            <span class="label-icon">{{ t.connections.sideALabel }}</span>
            {{ t.connections.origin }}
          </label>
          <div class="search-wrapper">
            <input
              v-model="searchA"
              @focus="showDropdownA = true"
              @input="showDropdownA = true; store.clearConnectionFinderSelection('a')"
              :placeholder="t.connections.searchPlaceholder"
              class="search-input"
            />
            <button
              v-if="selectionA.port"
              class="clear-btn"
              :aria-label="t.connections.clearSelection"
              @click="clearSelectionA"
            >
              {{ t.app.closeSymbol }}
            </button>
          </div>

          <div v-if="showDropdownA && !selectionA.port" class="dropdown">
            <div
              v-for="item in filteredPortsA"
              :key="`${item.device.id}-${item.port.id}`"
              class="dropdown-item"
              @click="selectPortA(item.device, item.port)"
            >
              <span class="device-name">{{ item.device.name }}</span>
              <span class="port-info">
                <span class="port-label">{{ item.port.label }}</span>
                <span class="port-type" :class="item.port.type.toLowerCase()">
                  {{ t.devices.portTypes[item.port.type] }}
                </span>
                <span v-if="item.port.patchbayId" class="patch-id">#{{ item.port.patchbayId }}</span>
                <span v-else class="not-linked">{{ t.connections.unlinked }}</span>
              </span>
            </div>
            <div v-if="filteredPortsA.length === 0" class="no-results">
              {{ t.connections.noResults }}
            </div>
          </div>

          <div v-if="selectionA.port" class="selection-info">
            <div class="selected-device">{{ selectionA.device?.name }}</div>
            <div class="selected-port">
              {{ selectionA.port.label }}
              <span class="port-type" :class="selectionA.port.type.toLowerCase()">
                {{ t.devices.portTypes[selectionA.port.type] }}
              </span>
            </div>
            <div v-if="selectionA.port.patchbayId" class="patch-number">
              {{ t.connections.patchbayLabel }}: <strong>#{{ selectionA.port.patchbayId }}</strong>
            </div>
            <div v-else class="not-linked-warning">{{ t.connections.notLinkedWarning }}</div>
          </div>
        </div>

        <button class="swap-btn" :title="t.connections.swapTitle" @click="swapSelections">
          <span>{{ t.connections.swapLabel }}</span>
        </button>

        <div class="selector-box">
          <label class="selector-label">
            <span class="label-icon">{{ t.connections.sideBLabel }}</span>
            {{ t.connections.destination }}
          </label>
          <div class="search-wrapper">
            <input
              v-model="searchB"
              @focus="showDropdownB = true"
              @input="showDropdownB = true; store.clearConnectionFinderSelection('b')"
              :placeholder="t.connections.searchPlaceholder"
              class="search-input"
            />
            <button
              v-if="selectionB.port"
              class="clear-btn"
              :aria-label="t.connections.clearSelection"
              @click="clearSelectionB"
            >
              {{ t.app.closeSymbol }}
            </button>
          </div>

          <div v-if="showDropdownB && !selectionB.port" class="dropdown">
            <div
              v-for="item in filteredPortsB"
              :key="`${item.device.id}-${item.port.id}`"
              class="dropdown-item"
              @click="selectPortB(item.device, item.port)"
            >
              <span class="device-name">{{ item.device.name }}</span>
              <span class="port-info">
                <span class="port-label">{{ item.port.label }}</span>
                <span class="port-type" :class="item.port.type.toLowerCase()">
                  {{ t.devices.portTypes[item.port.type] }}
                </span>
                <span v-if="item.port.patchbayId" class="patch-id">#{{ item.port.patchbayId }}</span>
                <span v-else class="not-linked">{{ t.connections.unlinked }}</span>
              </span>
            </div>
            <div v-if="filteredPortsB.length === 0" class="no-results">
              {{ t.connections.noResults }}
            </div>
          </div>

          <div v-if="selectionB.port" class="selection-info">
            <div class="selected-device">{{ selectionB.device?.name }}</div>
            <div class="selected-port">
              {{ selectionB.port.label }}
              <span class="port-type" :class="selectionB.port.type.toLowerCase()">
                {{ t.devices.portTypes[selectionB.port.type] }}
              </span>
            </div>
            <div v-if="selectionB.port.patchbayId" class="patch-number">
              {{ t.connections.patchbayLabel }}: <strong>#{{ selectionB.port.patchbayId }}</strong>
            </div>
            <div v-else class="not-linked-warning">{{ t.connections.notLinkedWarning }}</div>
          </div>
        </div>
      </div>

      <div v-if="connectionResult" class="result-container">
        <div v-if="connectionResult.type === 'success'" class="result success">
          <div class="result-header">
            <span class="result-icon">{{ t.connections.successBadge }}</span>
            <h3>{{ t.connections.resultSuccessTitle }}</h3>
          </div>
          <div class="connection-diagram">
            <div class="patch-point">
              <span class="patch-number-big">#{{ connectionResult.patchA }}</span>
              <span class="patch-device">{{ connectionResult.deviceA }}</span>
              <span class="patch-port">{{ connectionResult.portA }}</span>
            </div>
            <div class="connection-line">
              <span class="cable-icon">{{ t.connections.cableLabel }}</span>
            </div>
            <div class="patch-point">
              <span class="patch-number-big">#{{ connectionResult.patchB }}</span>
              <span class="patch-device">{{ connectionResult.deviceB }}</span>
              <span class="patch-port">{{ connectionResult.portB }}</span>
            </div>
          </div>
          <p class="result-instruction">
            {{ t.connections.resultInstruction(connectionResult.patchA, connectionResult.patchB) }}
          </p>
          <div class="result-actions">
            <button class="primary-btn" @click="goToPatchbay">
              {{ t.connections.goToPatchbay }}
            </button>
            <button class="ghost-btn" @click="copyInstruction">
              {{ t.connections.copyInstruction }}
            </button>
          </div>
        </div>

        <div v-else class="result warning">
          <div class="result-header">
            <span class="result-icon">{{ t.connections.errorBadge }}</span>
            <h3>{{ t.connections.linkRequiredTitle }}</h3>
          </div>
          <p>{{ t.connections.linkRequiredHint }}</p>
          <div class="missing-grid">
            <div v-for="missing in connectionResult.missing" :key="missing.side" class="missing-card">
              <div class="missing-title">
                {{ missing.selection.device?.name }} - {{ missing.selection.port?.label }}
              </div>
              <div class="missing-actions">
                <select v-model="mappingChoice[missing.side]" class="patch-select">
                  <option :value="null" disabled>{{ t.connections.pickPatchPoint }}</option>
                  <option
                    v-for="patch in availablePatchPoints"
                    :key="patch.id"
                    :value="patch.id"
                  >
                    {{ t.connections.patchPointOption(patch.id, patch.name) }}
                  </option>
                </select>
                <button class="primary-btn" @click="mapMissingPort(missing)">
                  {{ t.connections.mapPort }}
                </button>
                <button class="ghost-btn" @click="linkNow(missing)">
                  {{ t.connections.linkNowFor(`${missing.selection.device?.name} - ${missing.selection.port?.label}`) }}
                </button>
              </div>
            </div>
          </div>
          <p class="hint">{{ connectionResult.message }}</p>
        </div>
      </div>

      <div v-else class="empty-state">
        <div class="empty-icon">{{ t.connections.emptyIcon }}</div>
        <p>{{ t.connections.emptyTitle }}</p>
      </div>
    </div>
  </div>
</template>

<style scoped>
.connection-finder {
  max-width: 1000px;
  margin: 0 auto;
  height: 100%;
  overflow: hidden;
  background: var(--surface-1);
  border-radius: var(--radius-3);
  border: 1px solid var(--border-default);
  box-shadow: var(--shadow-1);
  display: flex;
  flex-direction: column;
}

.finder-header {
  text-align: center;
  margin: var(--space-5) var(--space-5) var(--space-4);
}

.finder-header h2 {
  margin: 0 0 var(--space-2) 0;
  font-size: 1.8rem;
  color: var(--text-primary);
}

.subtitle {
  color: var(--text-secondary);
  margin: 0;
}

.return-hint {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: var(--space-3);
  padding: var(--space-3);
  margin: 0 var(--space-5) var(--space-4);
  border-radius: var(--radius-2);
  border: 1px solid rgba(106, 163, 111, 0.5);
  background: rgba(61, 122, 88, 0.18);
}

.finder-body {
  flex: 1;
  overflow-y: auto;
  padding: 0 var(--space-5) var(--space-5);
}

.selectors-container {
  display: flex;
  gap: var(--space-4);
  align-items: flex-start;
  margin-bottom: var(--space-5);
}

.selector-box {
  flex: 1;
  background-color: var(--surface-2);
  border-radius: var(--radius-3);
  padding: var(--space-4);
  position: relative;
  border: 1px solid var(--border-default);
}

.selector-label {
  display: flex;
  align-items: center;
  gap: var(--space-2);
  color: var(--text-primary);
  font-weight: 600;
  margin-bottom: var(--space-3);
}

.label-icon {
  background-color: var(--accent);
  color: #0f120e;
  width: 28px;
  height: 28px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  font-size: 0.9rem;
}

.selector-box:last-of-type .label-icon {
  background-color: var(--accent-2);
}

.search-wrapper {
  position: relative;
}

.search-input {
  width: 100%;
  padding: 12px 40px 12px 12px;
  background-color: var(--surface-1);
  border: 1px solid var(--border-default);
  border-radius: var(--radius-2);
  color: var(--text-primary);
  font-size: 1rem;
  box-sizing: border-box;
}

.search-input:focus {
  outline: none;
  border-color: var(--accent);
}

.clear-btn {
  position: absolute;
  right: 8px;
  top: 50%;
  transform: translateY(-50%);
  background: var(--surface-3);
  border: none;
  color: var(--text-primary);
  width: 24px;
  height: 24px;
  border-radius: 50%;
  cursor: pointer;
  font-size: 0.85rem;
  display: flex;
  align-items: center;
  justify-content: center;
}

.dropdown {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  background-color: var(--surface-1);
  border: 1px solid var(--border-default);
  border-radius: var(--radius-2);
  max-height: 300px;
  overflow-y: auto;
  z-index: 100;
  margin-top: 4px;
}

.dropdown-item {
  padding: var(--space-3);
  cursor: pointer;
  border-bottom: 1px solid var(--border-default);
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.dropdown-item:hover {
  background-color: var(--surface-2);
}

.dropdown-item:last-child {
  border-bottom: none;
}

.device-name {
  font-weight: 600;
  color: var(--text-primary);
}

.port-info {
  display: flex;
  align-items: center;
  gap: var(--space-2);
  font-size: 0.9rem;
}

.port-label {
  color: var(--text-secondary);
}

.port-type {
  font-size: 0.7rem;
  padding: 2px 6px;
  border-radius: var(--radius-1);
  text-transform: uppercase;
  background: var(--surface-3);
  color: var(--text-muted);
}

.patch-id {
  background-color: var(--accent);
  color: #0f120e;
  padding: 2px 6px;
  border-radius: var(--radius-1);
  font-size: 0.75rem;
  font-weight: 600;
}

.not-linked {
  color: var(--text-muted);
  font-style: italic;
  font-size: 0.8rem;
}

.no-results {
  padding: var(--space-4);
  text-align: center;
  color: var(--text-muted);
}

.selection-info {
  margin-top: var(--space-4);
  padding-top: var(--space-4);
  border-top: 1px solid var(--border-default);
}

.selected-device {
  font-weight: 600;
  color: var(--text-primary);
  font-size: 1.1rem;
}

.selected-port {
  display: flex;
  align-items: center;
  gap: var(--space-2);
  color: var(--text-secondary);
  margin-top: 4px;
}

.patch-number {
  margin-top: var(--space-3);
  color: var(--accent-2);
  font-size: 1.1rem;
}

.not-linked-warning {
  margin-top: var(--space-3);
  color: var(--warning);
}

.swap-btn {
  background-color: var(--surface-3);
  border: 1px solid var(--border-default);
  color: var(--text-primary);
  width: 64px;
  height: 64px;
  border-radius: var(--radius-round);
  cursor: pointer;
  font-size: 0.85rem;
  margin-top: 52px;
  transition: all 0.2s;
  text-transform: uppercase;
  letter-spacing: 0.1em;
}

.swap-btn:hover {
  border-color: var(--accent);
  color: var(--text-primary);
}

.result-container {
  margin-top: var(--space-4);
}

.result {
  background-color: var(--surface-2);
  border-radius: var(--radius-3);
  padding: var(--space-5);
  text-align: center;
  border: 1px solid var(--border-default);
}

.result.success {
  border-color: rgba(61, 122, 88, 0.7);
}

.result.warning {
  border-color: rgba(212, 154, 79, 0.6);
}

.result-header {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: var(--space-2);
  margin-bottom: var(--space-4);
}

.result-header h3 {
  margin: 0;
  color: var(--text-primary);
}

.result-icon {
  font-size: 1rem;
  text-transform: uppercase;
  color: var(--text-muted);
}

.connection-diagram {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: var(--space-4);
  margin: var(--space-4) 0;
}

.patch-point {
  background-color: var(--surface-1);
  border-radius: var(--radius-3);
  padding: var(--space-4);
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
  min-width: 150px;
  border: 1px solid var(--border-default);
}

.patch-number-big {
  font-size: 1.9rem;
  font-weight: bold;
  color: var(--accent-2);
}

.patch-device {
  font-weight: 600;
  color: var(--text-primary);
}

.patch-port {
  color: var(--text-secondary);
  font-size: 0.9rem;
}

.connection-line {
  color: var(--accent);
  font-size: 0.9rem;
}

.cable-icon {
  display: inline-block;
  animation: pulse 1.5s ease-in-out infinite;
  text-transform: uppercase;
  letter-spacing: 0.12em;
}

@keyframes pulse {
  0%, 100% { opacity: 0.6; }
  50% { opacity: 1; }
}

.result-instruction {
  color: var(--text-primary);
  font-size: 1rem;
  margin: var(--space-4) 0;
}

.result-actions {
  display: flex;
  justify-content: center;
  gap: var(--space-3);
  flex-wrap: wrap;
}

.primary-btn {
  background-color: var(--accent);
  color: #0f120e;
  border: none;
  padding: 10px 18px;
  border-radius: var(--radius-2);
  font-size: 0.95rem;
  font-weight: 600;
  cursor: pointer;
}

.ghost-btn {
  background-color: transparent;
  color: var(--text-secondary);
  border: 1px solid var(--border-default);
  padding: 10px 18px;
  border-radius: var(--radius-2);
  font-size: 0.95rem;
  font-weight: 600;
  cursor: pointer;
}

.missing-grid {
  display: grid;
  gap: var(--space-3);
  margin-top: var(--space-4);
}

.missing-card {
  padding: var(--space-3);
  border-radius: var(--radius-2);
  border: 1px solid var(--border-default);
  background: var(--surface-1);
  text-align: left;
}

.missing-title {
  font-weight: 600;
  margin-bottom: var(--space-2);
}

.missing-actions {
  display: flex;
  flex-wrap: wrap;
  gap: var(--space-2);
  align-items: center;
}

.patch-select {
  min-width: 180px;
  padding: 8px 10px;
  border-radius: var(--radius-2);
  border: 1px solid var(--border-default);
  background: var(--surface-2);
  color: var(--text-primary);
}

.hint {
  color: var(--text-muted) !important;
  font-size: 0.9rem;
  margin-top: var(--space-3);
}

.empty-state {
  text-align: center;
  padding: var(--space-6) var(--space-4);
  color: var(--text-muted);
}

.empty-icon {
  font-size: 2rem;
  margin-bottom: var(--space-3);
}

.empty-state p {
  font-size: 1.1rem;
  max-width: 400px;
  margin: 0 auto;
}

@media (max-width: 960px) {
  .selectors-container {
    flex-direction: column;
    align-items: stretch;
  }

  .swap-btn {
    margin: 0 auto;
  }

  .connection-diagram {
    flex-direction: column;
  }
}
</style>

================
File: src/style.css
================
:root {
  --font-ui: "IBM Plex Sans", "Segoe UI", sans-serif;
  --font-display: "Cormorant Garamond", "Times New Roman", serif;

  --surface-bg: #161411;
  --surface-1: #1f1c18;
  --surface-2: #26221d;
  --surface-3: #2f2a23;

  --text-primary: #f2eadc;
  --text-secondary: #b7b0a3;
  --text-muted: #8d877a;

  --border-default: #3b352c;

  --accent: #3d7a58;
  --accent-2: #6aa36f;
  --danger: #b04b3d;
  --warning: #d49a4f;

  --space-1: 4px;
  --space-2: 8px;
  --space-3: 12px;
  --space-4: 16px;
  --space-5: 24px;
  --space-6: 32px;
  --space-7: 40px;

  --radius-1: 4px;
  --radius-2: 8px;
  --radius-3: 12px;
  --radius-4: 18px;
  --radius-round: 999px;

  --shadow-1: 0 8px 20px rgba(0, 0, 0, 0.35);
  --shadow-2: 0 16px 40px rgba(0, 0, 0, 0.35);

  font-family: var(--font-ui);
  line-height: 1.5;
  font-weight: 400;
  color: var(--text-primary);
  background-color: var(--surface-bg);
  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

* {
  box-sizing: border-box;
}

body {
  margin: 0;
  padding: 0;
  min-width: 320px;
  min-height: 100vh;
  background-color: var(--surface-bg);
  color: var(--text-primary);
  overflow: hidden;
}

body::before {
  content: "";
  position: fixed;
  inset: 0;
  background:
    radial-gradient(circle at 20% 20%, rgba(61, 122, 88, 0.18), transparent 45%),
    radial-gradient(circle at 80% 10%, rgba(212, 154, 79, 0.1), transparent 35%),
    linear-gradient(180deg, rgba(22, 20, 17, 0.95), rgba(12, 11, 9, 0.98));
  z-index: -1;
}

button,
input,
select,
textarea {
  font-family: inherit;
}

h1,
h2,
h3,
h4 {
  font-family: var(--font-display);
  letter-spacing: 0.02em;
}

@keyframes fade-in {
  from {
    opacity: 0;
    transform: translateY(6px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

================
File: Dockerfile
================
# Build
FROM node:20-alpine AS build
WORKDIR /app

COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

# Runtime con 'serve' (sin Nginx)
FROM node:20-alpine
WORKDIR /app
RUN npm i -g serve
COPY --from=build /app/dist ./dist
ENV PORT=3000
EXPOSE 3000
CMD ["serve", "-s", "dist", "-l", "3000"]

================
File: index.html
================
<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="./src/assets/el-riche-mark.svg" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@500;600&family=IBM+Plex+Sans:wght@400;500;600&display=swap"
    rel="stylesheet"
  />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>El Riche Patchbay</title>
</head>

<body>
  <div id="app"></div>
  <script type="module" src="/src/main.ts"></script>
</body>

</html>

================
File: tsconfig.app.json
================
{
  "extends": "@vue/tsconfig/tsconfig.dom.json",
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    },

    "resolveJsonModule": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src/**/*.ts", "src/**/*.tsx", "src/**/*.vue"]
}

================
File: src/components/PatchBayGrid.vue
================
<script setup lang="ts">
import { ref, computed, watch, nextTick } from 'vue'
import { store, type PatchBayNode, type Device, type DevicePort } from '../store'
import ConfirmDialog from '../ui/ConfirmDialog.vue'
import { strings } from '../ui/strings'

const t = strings
const nodes = computed(() => store.patchbayNodes)
const selectedCell = ref<PatchBayNode | null>(null)
const showLinkSearch = ref(false)
const searchQuery = ref('')
const gridSearchQuery = ref('')
const showOverwriteConfirm = ref(false)
const overwriteTarget = ref<{ node: PatchBayNode; deviceName: string; portLabel: string } | null>(null)

const rowLabels = t.patchbay.rowLabels
const columnLabels = Array.from({ length: 48 }, (_, index) => index + 1)

// Helper to get connection info
const getConnection = (patchbayId: number) => {
  return store.getDeviceByPatchbayId(patchbayId)
}

const isLinked = (patchbayId: number) => {
  return !!getConnection(patchbayId)
}

const isMatch = (node: PatchBayNode) => {
  if (!gridSearchQuery.value) return false
  const query = gridSearchQuery.value.toLowerCase()

  if (node.name.toLowerCase().includes(query)) return true

  const connection = getConnection(node.id)
  if (connection) {
    if (connection.device.name.toLowerCase().includes(query)) return true
    if (connection.port.label.toLowerCase().includes(query)) return true
  }

  return false
}

const isHighlightedConnection = (patchbayId: number) => {
  return store.highlightedPatchIds.includes(patchbayId)
}

const selectionBannerText = computed(() => {
  if (store.pendingLink) {
    return t.patchbay.linkingBanner(store.pendingLink.deviceName, store.pendingLink.portLabel)
  }
  return t.patchbay.linkingFallback
})

const getSectionNodes = (sectionIndex: number) => {
  return nodes.value.slice((sectionIndex - 1) * 96, sectionIndex * 96)
}

const getCellTooltip = (patchbayId: number) => {
  const connection = getConnection(patchbayId)
  if (!connection) return ''
  return t.patchbay.tooltip(connection.device.name, connection.port.label)
}

const handleCellClick = async (node: PatchBayNode) => {
  if (store.selectionMode) {
    const existing = getConnection(node.id)
    if (existing) {
      overwriteTarget.value = {
        node,
        deviceName: existing.device.name,
        portLabel: existing.port.label,
      }
      showOverwriteConfirm.value = true
      return
    }
    await store.completeLink(node.id)
  } else {
    selectedCell.value = node
  }
}

const closePopup = () => {
  selectedCell.value = null
  showLinkSearch.value = false
  searchQuery.value = ''
}

const handleUnlink = async () => {
  if (selectedCell.value) {
    const connection = getConnection(selectedCell.value.id)
    if (connection) {
      await store.unlinkPort(connection.device.id, connection.port.id)
    }
  }
}

const openLinkSearch = () => {
  showLinkSearch.value = true
}

const confirmOverwrite = async () => {
  if (overwriteTarget.value) {
    await store.completeLink(overwriteTarget.value.node.id)
  }
  showOverwriteConfirm.value = false
  overwriteTarget.value = null
}

const cancelOverwrite = () => {
  showOverwriteConfirm.value = false
  overwriteTarget.value = null
}

// Search Logic
const filteredDevices = computed(() => {
  if (!searchQuery.value) return store.devices
  const query = searchQuery.value.toLowerCase()
  return store.devices.filter(d => d.name.toLowerCase().includes(query))
})

const selectDeviceForLink = async (device: Device, port: DevicePort) => {
  if (selectedCell.value) {
    await store.linkPatchbayToDevice(selectedCell.value.id, device.id, port.id)
    closePopup()
  }
}

watch(() => store.patchbayFocusId, async (focusId) => {
  if (!focusId) return
  await nextTick()
  const target = document.querySelector(`[data-patch-id=\"${focusId}\"]`) as HTMLElement | null
  if (target) {
    target.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' })
  }
  store.patchbayFocusId = null
})
</script>

<template>
  <div class="main-container" :class="{ 'selection-mode': store.selectionMode }">
    <div class="top-controls">
      <div v-if="store.selectionMode" class="selection-banner">
        <span>{{ selectionBannerText }}</span>
        <button @click="store.cancelLinking()">{{ t.patchbay.cancel }}</button>
      </div>

      <div v-if="store.highlightedPatchIds.length > 0" class="highlight-banner">
        <span>{{ t.patchbay.showingConnection(store.highlightedPatchIds[0], store.highlightedPatchIds[1]) }}</span>
        <button @click="store.highlightedPatchIds = []">{{ t.patchbay.clearHighlights }}</button>
      </div>

      <div class="grid-controls">
        <input
          v-model="gridSearchQuery"
          :placeholder="t.patchbay.searchPlaceholder"
          class="grid-search-input"
        />
        <div class="grid-legend">
          <span class="legend-title">{{ t.patchbay.legendTitle }}</span>
          <span class="legend-chip linked">{{ t.patchbay.legendLinked }}</span>
          <span class="legend-chip open">{{ t.patchbay.legendOpen }}</span>
          <span class="legend-chip match">{{ t.patchbay.legendMatch }}</span>
          <span class="legend-chip highlight">{{ t.patchbay.legendHighlight }}</span>
        </div>
      </div>
    </div>

    <div class="grid-wrapper">
      <div v-for="sectionIndex in 3" :key="sectionIndex" class="grid-section" :class="'section-' + sectionIndex">
        <div class="grid-corner"></div>
        <div v-for="col in columnLabels" :key="`col-${sectionIndex}-${col}`" class="grid-col-label">
          {{ col }}
        </div>
        <div class="grid-row-label">{{ rowLabels[0] }}</div>
        <div
          v-for="item in getSectionNodes(sectionIndex).slice(0, 48)"
          :key="item.id"
          class="grid-cell"
          :class="{
            linked: isLinked(item.id),
            open: !isLinked(item.id),
            'highlight-match': isMatch(item),
            'highlight-connection': isHighlightedConnection(item.id),
          }"
          :data-patch-id="item.id"
          :data-tooltip="getCellTooltip(item.id) || null"
          @click="handleCellClick(item)"
        >
          <div class="cell-content">
            <span class="cell-text">{{ item.id }}</span>
          </div>
        </div>
        <div class="grid-row-label">{{ rowLabels[1] }}</div>
        <div
          v-for="item in getSectionNodes(sectionIndex).slice(48, 96)"
          :key="item.id"
          class="grid-cell"
          :class="{
            linked: isLinked(item.id),
            open: !isLinked(item.id),
            'highlight-match': isMatch(item),
            'highlight-connection': isHighlightedConnection(item.id),
          }"
          :data-patch-id="item.id"
          :data-tooltip="getCellTooltip(item.id) || null"
          @click="handleCellClick(item)"
        >
          <div class="cell-content">
            <span class="cell-text">{{ item.id }}</span>
          </div>
        </div>
      </div>
    </div>

    <ConfirmDialog
      v-if="showOverwriteConfirm && overwriteTarget"
      :title="t.confirm.overwriteTitle"
      :message="t.confirm.overwriteMessage(overwriteTarget.deviceName, overwriteTarget.portLabel)"
      @confirm="confirmOverwrite"
      @cancel="cancelOverwrite"
    />

    <div v-if="selectedCell && !showLinkSearch" class="modal-overlay" @click="closePopup">
      <div class="modal-content" @click.stop>
        <h2>{{ t.patchbay.patchPointTitle(selectedCell.id) }}</h2>
        <p><strong>{{ t.patchbay.nameLabel }}:</strong> {{ selectedCell.name }}</p>
        <p><strong>{{ t.patchbay.typeLabel }}:</strong> {{ selectedCell.type }}</p>
        <p><strong>{{ t.patchbay.descriptionLabel }}:</strong> {{ selectedCell.description }}</p>

        <div class="connection-status">
          <h3>{{ t.patchbay.connectionLabel }}</h3>
          <div v-if="getConnection(selectedCell.id)" class="connected-info">
            <p>
              {{ t.patchbay.connectedTo }}:
              <strong>{{ getConnection(selectedCell.id)?.device.name }}</strong>
            </p>
            <p>
              {{ t.patchbay.portLabel }}:
              <strong>{{ getConnection(selectedCell.id)?.port.label }}</strong>
            </p>
            <button class="unlink-btn" @click="handleUnlink">{{ t.patchbay.unlink }}</button>
          </div>
          <div v-else class="disconnected-info">
            <p>{{ t.patchbay.notConnected }}</p>
            <button class="link-btn" @click="openLinkSearch">{{ t.patchbay.linkDeviceAction }}</button>
          </div>
        </div>

        <button class="close-btn-main" @click="closePopup">{{ t.patchbay.close }}</button>
      </div>
    </div>

    <div v-if="showLinkSearch" class="modal-overlay" @click="closePopup">
      <div class="modal-content search-modal" @click.stop>
        <div class="modal-header">
          <h2>{{ t.patchbay.linkDeviceTitle(selectedCell?.id || 0) }}</h2>
          <button class="close-btn" @click="closePopup">{{ t.app.closeSymbol }}</button>
        </div>

        <input
          v-model="searchQuery"
          :placeholder="t.patchbay.searchDevicesPlaceholder"
          class="search-input"
          autofocus
        />

        <div class="device-search-list">
          <div v-for="device in filteredDevices" :key="device.id" class="search-device-item">
            <div class="device-name">{{ device.name }}</div>
            <div class="device-ports">
              <button
                v-for="port in device.ports"
                :key="port.id"
                class="port-select-btn"
                :class="{ active: port.patchbayId === selectedCell?.id, occupied: port.patchbayId && port.patchbayId !== selectedCell?.id }"
                :disabled="!!(port.patchbayId && port.patchbayId !== selectedCell?.id)"
                @click="selectDeviceForLink(device, port)"
              >
                {{ port.label }}
                <span v-if="port.patchbayId && port.patchbayId !== selectedCell?.id" class="occupied-tag">
                  {{ t.patchbay.occupiedTag(port.patchbayId) }}
                </span>
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<style scoped>
.main-container {
  display: flex;
  flex-direction: column;
  gap: var(--space-4);
  padding: var(--space-5);
  background-color: var(--surface-1);
  width: 100%;
  height: 100%;
  border-radius: var(--radius-3);
  border: 1px solid var(--border-default);
  box-shadow: var(--shadow-1);
  overflow: auto;
}

.selection-mode {
  border: 2px solid rgba(61, 122, 88, 0.9);
  box-shadow: 0 0 0 2px rgba(61, 122, 88, 0.2);
}

.selection-banner {
  background-color: rgba(61, 122, 88, 0.2);
  color: var(--text-primary);
  padding: var(--space-2) var(--space-3);
  text-align: center;
  font-weight: 600;
  display: flex;
  justify-content: center;
  gap: var(--space-3);
  align-items: center;
  border-radius: var(--radius-2);
  border: 1px solid rgba(61, 122, 88, 0.4);
}

.selection-banner button {
  background: var(--surface-1);
  color: var(--text-secondary);
  border: 1px solid var(--border-default);
  padding: 4px 12px;
  border-radius: var(--radius-2);
  cursor: pointer;
}

.highlight-banner {
  background: linear-gradient(120deg, rgba(61, 122, 88, 0.3), rgba(212, 154, 79, 0.25));
  color: var(--text-primary);
  padding: var(--space-2) var(--space-3);
  text-align: center;
  font-weight: 500;
  display: flex;
  justify-content: center;
  gap: var(--space-3);
  align-items: center;
  border-radius: var(--radius-2);
  border: 1px solid rgba(212, 154, 79, 0.3);
}

.highlight-banner button {
  background: transparent;
  color: var(--text-secondary);
  border: 1px solid var(--border-default);
  padding: 4px 12px;
  border-radius: var(--radius-2);
  cursor: pointer;
}

.grid-controls {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: var(--space-3);
  flex-wrap: wrap;
}

.grid-search-input {
  width: 100%;
  max-width: 360px;
  padding: 10px 12px;
  background-color: var(--surface-2);
  border: 1px solid var(--border-default);
  color: var(--text-primary);
  border-radius: var(--radius-2);
}

.grid-legend {
  display: flex;
  align-items: center;
  gap: var(--space-2);
  flex-wrap: wrap;
}

.legend-title {
  color: var(--text-muted);
  font-size: 0.85rem;
  text-transform: uppercase;
  letter-spacing: 0.12em;
}

.legend-chip {
  padding: 4px 10px;
  border-radius: var(--radius-round);
  font-size: 0.8rem;
  border: 1px solid var(--border-default);
  color: var(--text-secondary);
}

.legend-chip.linked {
  border-color: rgba(106, 163, 111, 0.6);
}

.legend-chip.open {
  border-color: rgba(141, 135, 122, 0.6);
}

.legend-chip.match {
  border-color: rgba(212, 154, 79, 0.6);
}

.legend-chip.highlight {
  border-color: rgba(61, 122, 88, 0.7);
}

.grid-wrapper {
  display: flex;
  flex-direction: column;
  gap: var(--space-4);
  width: 100%;
}

.grid-section {
  display: grid;
  grid-template-columns: 32px repeat(48, minmax(22px, 1fr));
  grid-template-rows: auto repeat(2, minmax(28px, 1fr));
  gap: 4px;
  width: 100%;
  min-width: 1280px;
  position: relative;
}

.grid-corner {
  position: sticky;
  left: 0;
  top: 0;
  background: var(--surface-1);
  z-index: 2;
}

.grid-col-label {
  font-size: 0.65rem;
  color: var(--text-muted);
  text-align: center;
  position: sticky;
  top: 0;
  background: var(--surface-1);
  padding-bottom: 4px;
  z-index: 2;
}

.grid-row-label {
  font-size: 0.75rem;
  color: var(--text-muted);
  text-align: center;
  display: flex;
  align-items: center;
  justify-content: center;
  position: sticky;
  left: 0;
  background: var(--surface-1);
  z-index: 1;
}

.grid-cell {
  background-color: var(--surface-2);
  border: 1px solid var(--border-default);
  border-radius: var(--radius-1);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background-color 0.2s, border-color 0.2s, transform 0.2s;
  height: 34px;
  position: relative;
}

.grid-cell.open {
  background-color: var(--surface-2);
}

.grid-cell.linked {
  background-color: rgba(61, 122, 88, 0.25);
  border-color: rgba(61, 122, 88, 0.6);
}

.grid-cell:hover {
  border-color: rgba(212, 154, 79, 0.6);
  transform: translateY(-1px);
}

.grid-cell[data-tooltip]:hover::after {
  content: attr(data-tooltip);
  position: absolute;
  left: 50%;
  top: -34px;
  transform: translateX(-50%);
  background: var(--surface-3);
  color: var(--text-primary);
  padding: 6px 10px;
  border-radius: var(--radius-2);
  border: 1px solid var(--border-default);
  white-space: nowrap;
  font-size: 0.75rem;
  z-index: 20;
  box-shadow: var(--shadow-1);
}

.grid-cell.highlight-match {
  background-color: rgba(212, 154, 79, 0.35);
  border-color: rgba(212, 154, 79, 0.7);
  box-shadow: 0 0 6px rgba(212, 154, 79, 0.3);
  z-index: 1;
}

.grid-cell.highlight-connection {
  background-color: rgba(61, 122, 88, 0.6);
  border-color: rgba(61, 122, 88, 0.9);
  box-shadow: 0 0 18px rgba(61, 122, 88, 0.5);
  z-index: 10;
  animation: connection-pulse 1s ease-in-out infinite;
  transform: scale(1.08);
  border-width: 2px;
}

.grid-cell.highlight-connection .cell-text {
  font-weight: bold;
  font-size: 0.75rem;
}

@keyframes connection-pulse {
  0%, 100% {
    box-shadow: 0 0 12px rgba(61, 122, 88, 0.5);
  }
  50% {
    box-shadow: 0 0 18px rgba(106, 163, 111, 0.7);
  }
}

.cell-text {
  font-size: 0.6rem;
  color: var(--text-primary);
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
  padding: 1px;
}

.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(7, 6, 5, 0.7);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.modal-content {
  background-color: var(--surface-2);
  padding: var(--space-5);
  border-radius: var(--radius-3);
  min-width: 300px;
  box-shadow: var(--shadow-2);
  color: var(--text-primary);
  border: 1px solid var(--border-default);
}

.modal-content.search-modal {
  width: 640px;
  max-height: 80vh;
  display: flex;
  flex-direction: column;
  padding: 0;
}

.modal-header {
  padding: var(--space-4);
  border-bottom: 1px solid var(--border-default);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.close-btn {
  background: none;
  border: none;
  color: var(--text-secondary);
  font-size: 1.5rem;
  cursor: pointer;
}

.connection-status {
  margin: var(--space-4) 0;
  padding: var(--space-3);
  background-color: var(--surface-1);
  border-radius: var(--radius-2);
  border: 1px solid var(--border-default);
}

.link-btn {
  background-color: var(--accent);
  color: #0c0e0b;
  border: none;
  padding: 8px 16px;
  border-radius: var(--radius-2);
  cursor: pointer;
  margin-top: var(--space-2);
  font-weight: 600;
}

.unlink-btn {
  background-color: var(--danger);
  color: #fdf7ee;
  border: none;
  padding: 8px 16px;
  border-radius: var(--radius-2);
  cursor: pointer;
  margin-top: var(--space-2);
}

.close-btn-main {
  margin-top: var(--space-3);
  padding: 0.5rem 1rem;
  background-color: var(--surface-3);
  color: var(--text-primary);
  border: 1px solid var(--border-default);
  border-radius: var(--radius-2);
  cursor: pointer;
}

.search-input {
  margin: var(--space-4);
  padding: 10px;
  background-color: var(--surface-1);
  border: 1px solid var(--border-default);
  color: var(--text-primary);
  border-radius: var(--radius-2);
}

.device-search-list {
  overflow-y: auto;
  padding: 0 var(--space-4) var(--space-4) var(--space-4);
}

.search-device-item {
  margin-bottom: var(--space-3);
  background-color: var(--surface-1);
  padding: var(--space-3);
  border-radius: var(--radius-2);
  border: 1px solid var(--border-default);
}

.device-name {
  font-weight: bold;
  margin-bottom: var(--space-2);
  color: var(--text-primary);
}

.device-ports {
  display: flex;
  flex-wrap: wrap;
  gap: var(--space-2);
}

.port-select-btn {
  background-color: var(--surface-2);
  border: 1px solid var(--border-default);
  color: var(--text-primary);
  padding: 4px 8px;
  border-radius: var(--radius-2);
  cursor: pointer;
  font-size: 0.85rem;
}

.port-select-btn:hover:not(:disabled) {
  background-color: rgba(61, 122, 88, 0.25);
}

.port-select-btn.active {
  background-color: var(--accent);
  color: #0c0e0b;
  border-color: var(--accent);
}

.port-select-btn.occupied {
  opacity: 0.5;
  cursor: not-allowed;
  background-color: var(--surface-2);
}

.occupied-tag {
  font-size: 0.7rem;
  color: var(--text-muted);
}

@media (max-width: 960px) {
  .main-container {
    padding: var(--space-3);
  }

  .grid-section {
    min-width: 960px;
  }
}
</style>

================
File: src/lib/api.ts
================
// API client for patchbay backend
import { getAuthToken } from './authToken'

const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:8088'

// API Types (snake_case from backend)
export interface ApiPatchbayPoint {
  id: number
  name: string
  description: string
  type: string
}

export interface ApiPort {
  id: string
  label: string
  type: 'Input' | 'Output' | 'Other'
  patchbay_id: number | null
}

export interface ApiDevice {
  id: number
  name: string
  type: string
  ports: ApiPort[]
  image_url?: string | null
  image_updated_at?: string | null
}

export interface ApiState {
  patchbay_points: ApiPatchbayPoint[]
  devices: ApiDevice[]
}

export interface ApiPortLinkRequest {
  patchbay_id: number
}

export interface ApiPortLinkResponse extends ApiPort {
  unlinked_port_id?: string | null
}

export interface ApiDeviceCreate {
  name: string
  type: string
  ports: Array<{
    label: string
    type: 'Input' | 'Output' | 'Other'
    patchbay_id: number | null
  }>
}

export interface ApiDeviceUpdate {
  name: string
  type: string
  ports: Array<{
    id?: string
    label: string
    type: 'Input' | 'Output' | 'Other'
    patchbay_id?: number | null
  }>
}

// HTTP client
async function request<T>(path: string, options?: RequestInit, isRetry = false): Promise<T> {
  const url = `${API_URL}${path}`
  const body = options?.body
  const headers: Record<string, string> = {
    ...(options?.headers as Record<string, string>),
  }
  
  // Inject Authorization token if available
  const token = await getAuthToken({ skipCache: isRetry })
  if (token) {
    headers['Authorization'] = `Bearer ${token}`
  }
  
  try {
    const response = await fetch(url, {
      ...options,
      headers: {
        ...(body instanceof FormData ? {} : { 'Content-Type': 'application/json' }),
        ...headers,
      },
    })

    if (!response.ok) {
      // Handle 401: retry once with fresh token
      if (response.status === 401 && !isRetry && token) {
        console.warn('[API] Got 401, retrying with fresh token...')
        return request<T>(path, options, true)
      }
      
      const errorText = await response.text()
      
      // Throw specific error for auth issues
      if (response.status === 401) {
        throw new Error('AUTH_EXPIRED')
      }
      if (response.status === 403) {
        throw new Error('AUTH_FORBIDDEN')
      }
      
      throw new Error(`HTTP ${response.status}: ${errorText}`)
    }

    return await response.json()
  } catch (error) {
    console.error(`API request failed: ${path}`, error)
    throw error
  }
}

// API methods
export const api = {
  async getState(): Promise<ApiState> {
    return request<ApiState>('/state')
  },

  async createDevice(payload: ApiDeviceCreate): Promise<ApiDevice> {
    return request<ApiDevice>('/devices', {
      method: 'POST',
      body: JSON.stringify(payload),
    })
  },

  async deleteDevice(deviceId: number): Promise<ApiDevice> {
    return request<ApiDevice>(`/devices/${deviceId}`, {
      method: 'DELETE',
    })
  },

  async updateDevice(deviceId: number, payload: ApiDeviceUpdate): Promise<ApiDevice> {
    return request<ApiDevice>(`/devices/${deviceId}`, {
      method: 'PUT',
      body: JSON.stringify(payload),
    })
  },

  async linkPort(portId: string, patchbayId: number): Promise<ApiPortLinkResponse> {
    return request<ApiPortLinkResponse>(`/ports/${portId}/link`, {
      method: 'POST',
      body: JSON.stringify({ patchbay_id: patchbayId }),
    })
  },

  async updatePortPatchbay(portId: string, patchbayId: number | null): Promise<ApiPort> {
    return request<ApiPort>(`/ports/${portId}/patchbay`, {
      method: 'PUT',
      body: JSON.stringify({ patchbay_id: patchbayId }),
    })
  },

  async unlinkPort(portId: string): Promise<ApiPort> {
    return request<ApiPort>(`/ports/${portId}/unlink`, {
      method: 'POST',
    })
  },

  async parseDeviceFromImage(image: File): Promise<ApiDevice> {
    const formData = new FormData()
    formData.append('image', image)

    return request<ApiDevice>('/devices/parse-image', {
      method: 'POST',
      body: formData,
    })
  },

  async uploadDeviceImage(deviceId: number, image: File): Promise<ApiDevice> {
    // Client-side validation
    if (!image.type.startsWith('image/')) {
      throw new Error('Invalid file type. Please upload an image file.')
    }
    const MAX_SIZE = 12 * 1024 * 1024 // 12MB
    if (image.size > MAX_SIZE) {
      throw new Error('Image too large. Maximum size is 12MB.')
    }

    const formData = new FormData()
    formData.append('image', image)

    return request<ApiDevice>(`/devices/${deviceId}/image`, {
      method: 'POST',
      body: formData,
    })
  },

  buildAbsoluteUrl(relativeOrAbsolute: string): string {
    if (relativeOrAbsolute.startsWith('http://') || relativeOrAbsolute.startsWith('https://')) {
      return relativeOrAbsolute
    }
    return `${API_URL}${relativeOrAbsolute}`
  },

  getDeviceImageSrc(imageUrl: string | null | undefined, imageUpdatedAt: string | null | undefined): string | null {
    if (!imageUrl) return null
    
    const base = this.buildAbsoluteUrl(imageUrl)
    const cacheBust = imageUpdatedAt ? `?v=${encodeURIComponent(imageUpdatedAt)}` : ''
    return base + cacheBust
  },
}

================
File: src/vite-env.d.ts
================
/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly VITE_API_URL: string
}

interface ImportMeta {
  readonly env: ImportMetaEnv
}

================
File: README.md
================
# üéõÔ∏è Audio Tech Web - Patchbay Manager

Sistema web para gestionar y visualizar conexiones de patchbay en estudios de audio. Permite administrar dispositivos de audio y sus puertos, vincul√°ndolos con puntos espec√≠ficos del patchbay.

## ‚ú® Caracter√≠sticas

- **Visualizaci√≥n de Patchbay**: Grilla interactiva de 96 puntos (4 filas x 24 columnas)
- **Gesti√≥n de Dispositivos**: CRUD completo para equipos de audio (preamps, compresores, EQs, etc.)
- **Administraci√≥n de Puertos**: Cada dispositivo puede tener m√∫ltiples puertos (Input/Output/Other)
- **Vinculaci√≥n Din√°mica**: Conecta puertos de dispositivos a puntos del patchbay
- **B√∫squeda y Filtrado**: Encuentra r√°pidamente dispositivos y conexiones
- **Persistencia con API**: Datos guardados en PostgreSQL mediante FastAPI backend

## üõ†Ô∏è Tech Stack

### Frontend
- **Frontend**: Vue 3 + TypeScript
- **Build Tool**: Vite
- **State Management**: Store reactivo con Vue Composition API
- **Estilos**: CSS vanilla con dise√±o oscuro profesional

### Backend
- **API**: FastAPI
- **Database**: PostgreSQL 16
- **ORM**: SQLAlchemy 2.0
- **Migrations**: Alembic

## üìã Requisitos Previos

- Node.js 18+
- Docker & Docker Compose
- npm o yarn

## üöÄ Instalaci√≥n

### Backend (API + Database)

1. **Ir a la carpeta del backend**
   ```bash
   cd api-backend
   ```

2. **Copiar variables de entorno**
   ```bash
   cp .env.example .env
   ```

3. **Levantar servicios con Docker**
   ```bash
   docker compose up --build
   ```

   Esto levanta:
   - PostgreSQL en puerto `5435`
   - API FastAPI en puerto `8088`
   - pgAdmin en puerto `8090`

4. **Verificar API**
   - Swagger: http://localhost:8088/docs
   - Health: http://localhost:8088/health

### Frontend (Vue App)

1. **Instalar dependencias**
   ```bash
   npm install
   ```

2. **Configurar variables de entorno**

   ```bash
   cp .env.example .env
   ```

   Editar `.env` si necesitas otro host:
   ```env
   VITE_API_URL=http://localhost:8088
   ```

3. **Iniciar servidor de desarrollo**
   ```bash
   npm run dev
   ```

   La app estar√° disponible en http://localhost:5173

## üìÅ Estructura del Proyecto

```
pepper/
‚îú‚îÄ‚îÄ src/                        # Frontend Vue
‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PatchBayGrid.vue    # Grilla visual del patchbay
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DevicesManager.vue  # Gesti√≥n de dispositivos
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ConnectionFinder.vue
‚îÇ   ‚îú‚îÄ‚îÄ store/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts            # Estado global + API calls
‚îÇ   ‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ api.ts              # Cliente HTTP para backend
‚îÇ   ‚îú‚îÄ‚îÄ data/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ patchbayData.json   # Datos est√°ticos del patchbay
‚îÇ   ‚îú‚îÄ‚îÄ App.vue
‚îÇ   ‚îî‚îÄ‚îÄ main.ts
‚îî‚îÄ‚îÄ api-backend/                # Backend FastAPI
    ‚îú‚îÄ‚îÄ app/
    ‚îÇ   ‚îú‚îÄ‚îÄ api/routes/         # Endpoints HTTP
    ‚îÇ   ‚îú‚îÄ‚îÄ models/             # Modelos SQLAlchemy
    ‚îÇ   ‚îú‚îÄ‚îÄ schemas/            # Schemas Pydantic
    ‚îÇ   ‚îî‚îÄ‚îÄ services/           # L√≥gica de negocio
    ‚îú‚îÄ‚îÄ alembic/                # Migraciones DB
    ‚îî‚îÄ‚îÄ docker-compose.yml
```

## üóÑÔ∏è Modelo de Datos

La API maneja tres entidades principales:

### Devices
Equipos de audio (preamps, synths, etc.)
- `id`, `name`, `type`

### Ports
Puertos de entrada/salida de cada device
- `id`, `device_id`, `label`, `type` (Input/Output/Other), `patchbay_id`

### Patchbay Points
Puntos f√≠sicos del patchbay
- `id`, `name`, `description`, `type`

## üéÆ Uso

### Gestionar Dispositivos
1. Ir a la pesta√±a **Devices**
2. Click en **Add Device** para crear un nuevo equipo
3. Agregar puertos con su tipo (Input/Output/Other)
4. Guardar el dispositivo

### Vincular a Patchbay
1. Seleccionar un dispositivo
2. En un puerto, click en **Link**
3. Se abrir√° el patchbay - seleccionar el punto deseado
4. La conexi√≥n queda establecida

### Ver Conexiones
- En el **Patchbay**, los puntos conectados muestran el dispositivo vinculado
- En **Devices**, cada puerto muestra su punto de patchbay asignado

## üìú Scripts Disponibles

### Frontend
```bash
npm run dev      # Servidor de desarrollo
npm run build    # Build de producci√≥n
npm run preview  # Preview del build
```

### Backend
```bash
docker compose up         # Levantar servicios
docker compose down       # Detener servicios
docker compose logs api   # Ver logs de la API
```

## üê≥ Docker

Para correr todo el stack completo:

```bash
# Backend
cd api-backend && docker compose up -d

# Frontend (en otra terminal)
npm run dev
```

O para deployar el frontend tambi√©n con Docker, usar el `docker-compose.yml` en la ra√≠z.

## üîß API Endpoints

- `GET /state` - Estado completo (patchbay + devices)
- `POST /devices` - Crear dispositivo con puertos
- `DELETE /devices/{id}` - Borrar dispositivo
- `POST /ports/{id}/link` - Vincular puerto a patchbay
- `POST /ports/{id}/unlink` - Desvincular puerto
- `PUT /ports/{id}/patchbay` - Actualizar patchbay de un puerto

Ver documentaci√≥n completa en http://localhost:8088/docs

## üìÑ Licencia

MIT


---

Desarrollado con üéöÔ∏è para t√©cnicos de audio

================
File: package.json
================
{
  "name": "audio-tech-web",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vue-tsc -b && vite build",
    "preview": "vite preview",
    "verify-clerk": "./scripts/verify-clerk-setup.sh",
    "type-check": "vue-tsc --noEmit"
  },
  "dependencies": {
    "@clerk/vue": "^1.17.8",
    "pinia": "^3.0.3",
    "vue": "^3.5.18",
    "vue-router": "^4.5.1"
  },
  "devDependencies": {
    "@types/node": "^20.11.30",
    "@vitejs/plugin-vue": "^6.0.1",
    "@vue/tsconfig": "^0.7.0",
    "typescript": "~5.8.3",
    "vite": "^7.1.2",
    "vue-tsc": "^3.0.5"
  }
}

================
File: docker-compose.yml
================
services:
  web:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: pepper-frontend
    ports:
      - "8080:3000"
    restart: unless-stopped
    networks:
      - pepper-network

networks:
  pepper-network:
    driver: bridge

================
File: src/components/DevicesManager.vue
================
<script setup lang="ts">
import { ref, computed, watch, onBeforeUnmount, onMounted } from 'vue'
import { api } from '../lib/api'
import { store, type Device, type DevicePort } from '../store'
import { strings } from '../ui/strings'
import ConfirmDialog from '../ui/ConfirmDialog.vue'

const t = strings

const searchQuery = ref('')
const isLoading = ref(false)
const isDesktop = ref(window.innerWidth >= 1024)

const updateViewport = () => {
  isDesktop.value = window.innerWidth >= 1024
}

onMounted(() => {
  window.addEventListener('resize', updateViewport)
})

const showError = (message: string) => {
  store.pushToast({ type: 'error', message })
}

const filteredDevices = computed(() => {
  if (!searchQuery.value) return store.devices
  const query = searchQuery.value.toLowerCase()
  return store.devices.filter(device =>
    device.name.toLowerCase().includes(query) ||
    device.type.toLowerCase().includes(query) ||
    device.ports.some(p => p.label.toLowerCase().includes(query))
  )
})

const selectedDevice = ref<Device | null>(null)
const showAddModal = ref(false)
const addDeviceMode = ref<'manual' | 'ai'>('manual')
const editingDeviceId = ref<number | null>(null)
const editSnapshot = ref<{ device: { name: string; type: string }; ports: DevicePort[] } | null>(null)
const deleteTarget = ref<Device | null>(null)
const DRAFT_STORAGE_KEY = 'el-riche.addDeviceDraft'
const LEGACY_DRAFT_STORAGE_KEY = 'pepper.addDeviceDraft'

const deviceTypeOptions = t.devices.deviceTypes
const portTypeOptions = Object.keys(t.devices.portTypes) as Array<keyof typeof t.devices.portTypes>
const fallbackDeviceType = deviceTypeOptions[deviceTypeOptions.length - 1]

const newDevice = ref({
  name: '',
  type: deviceTypeOptions[0],
})

const newPorts = ref<Array<{ id?: string; label: string; type: 'Input' | 'Output' | 'Other'; patchbayId?: number | null }>>([])

const aiPreviewUrl = ref<string | null>(null)
const aiLoading = ref(false)
const aiStatusMessage = ref<string | null>(null)
const isEditing = computed(() => editingDeviceId.value !== null)

// Image upload state
const pendingImageFile = ref<File | null>(null)
const pendingImagePreviewUrl = ref<string | null>(null)
const pendingImageError = ref<string | null>(null)
const isUploadingImage = ref(false)

const aiStep = computed(() => {
  if (!aiPreviewUrl.value) return 'upload'
  if (aiLoading.value) return 'processing'
  if (aiStatusMessage.value) return 'review'
  return 'upload'
})

const addPort = () => {
  newPorts.value.push({
    label: t.devices.addPortLabel(newPorts.value.length + 1),
    type: portTypeOptions[0],
    patchbayId: null,
  })
}

const removePort = (index: number) => {
  newPorts.value.splice(index, 1)
}

const selectDevice = (device: Device) => {
  selectedDevice.value = device
}

const closeDetail = () => {
  selectedDevice.value = null
}

const normalizeDeviceType = (value: string | null | undefined) => {
  const raw = value?.trim()
  if (!raw) return fallbackDeviceType
  const match = deviceTypeOptions.find(option => option.toLowerCase() === raw.toLowerCase())
  return match || fallbackDeviceType
}

const saveDraft = () => {
  if (isEditing.value) return
  const draft = {
    device: newDevice.value,
    ports: newPorts.value,
  }
  localStorage.setItem(DRAFT_STORAGE_KEY, JSON.stringify(draft))
}

const loadDraft = () => {
  const raw = localStorage.getItem(DRAFT_STORAGE_KEY) || localStorage.getItem(LEGACY_DRAFT_STORAGE_KEY)
  if (!raw) return
  try {
    const draft = JSON.parse(raw)
    if (draft?.device?.name !== undefined && draft?.device?.type !== undefined) {
      newDevice.value = {
        name: String(draft.device.name ?? ''),
        type: normalizeDeviceType(String(draft.device.type ?? fallbackDeviceType)),
      }
    }
    if (Array.isArray(draft?.ports)) {
      newPorts.value = draft.ports
        .filter((port: any) => port?.label && port?.type)
        .map((port: any) => ({
          label: String(port.label),
          type: port.type as 'Input' | 'Output' | 'Other',
          patchbayId: port.patchbayId ?? null,
          id: port.id || undefined,
        }))
    }
  } catch (err) {
    console.warn('Failed to load add device draft', err)
  }
}

const clearDraft = () => {
  localStorage.removeItem(DRAFT_STORAGE_KEY)
  localStorage.removeItem(LEGACY_DRAFT_STORAGE_KEY)
}

const resetAddForm = (clear = false) => {
  newDevice.value = { name: '', type: deviceTypeOptions[0] }
  newPorts.value = []
  addDeviceMode.value = 'manual'
  aiStatusMessage.value = null
  if (aiPreviewUrl.value) {
    URL.revokeObjectURL(aiPreviewUrl.value)
  }
  aiPreviewUrl.value = null
  clearPendingImage()
  if (clear) {
    clearDraft()
  }
}

const closeAddModal = () => {
  showAddModal.value = false
  if (isEditing.value) {
    editingDeviceId.value = null
    editSnapshot.value = null
    resetAddForm()
  } else {
    saveDraft()
  }
}

const openAddModal = () => {
  showAddModal.value = true
  loadDraft()
}

const openEditModal = (device: Device) => {
  editingDeviceId.value = device.id
  editSnapshot.value = {
    device: { name: device.name, type: normalizeDeviceType(device.type) },
    ports: device.ports.map(port => ({ ...port })),
  }
  newDevice.value = { name: device.name, type: normalizeDeviceType(device.type) }
  newPorts.value = device.ports.map(port => ({
    id: port.id,
    label: port.label,
    type: port.type,
    patchbayId: port.patchbayId,
  }))
  addDeviceMode.value = 'manual'
  aiStatusMessage.value = null
  showAddModal.value = true
}

const setAiImageFile = (file: File | null) => {
  if (aiPreviewUrl.value) {
    URL.revokeObjectURL(aiPreviewUrl.value)
  }
  aiPreviewUrl.value = file ? URL.createObjectURL(file) : null
}

const setPendingImageFile = (file: File | null) => {
  // Revoke old preview URL to prevent memory leaks
  if (pendingImagePreviewUrl.value) {
    URL.revokeObjectURL(pendingImagePreviewUrl.value)
  }
  
  pendingImageFile.value = file
  pendingImagePreviewUrl.value = file ? URL.createObjectURL(file) : null
  pendingImageError.value = null
  
  // Validate file
  if (file) {
    if (!file.type.startsWith('image/')) {
      pendingImageError.value = 'Invalid file type. Please upload an image file (JPG, PNG, etc.)'
      pendingImageFile.value = null
      pendingImagePreviewUrl.value = null
    } else if (file.size > 12 * 1024 * 1024) {
      pendingImageError.value = 'Image too large. Maximum size is 12MB.'
      pendingImageFile.value = null
      pendingImagePreviewUrl.value = null
    }
  }
}

const clearPendingImage = () => {
  if (pendingImagePreviewUrl.value) {
    URL.revokeObjectURL(pendingImagePreviewUrl.value)
  }
  pendingImageFile.value = null
  pendingImagePreviewUrl.value = null
  pendingImageError.value = null
}

const getDeviceImageSrc = (device: Device) => {
  return api.getDeviceImageSrc(device.imageUrl, device.imageUpdatedAt)
}

const handleResetForm = () => {
  if (isEditing.value && editSnapshot.value) {
    newDevice.value = { ...editSnapshot.value.device }
    newPorts.value = editSnapshot.value.ports.map(port => ({
      id: port.id,
      label: port.label,
      type: port.type,
      patchbayId: port.patchbayId,
    }))
    aiStatusMessage.value = null
    return
  }
  resetAddForm(true)
}

const handleAiFileChange = async (event: Event) => {
  const input = event.target as HTMLInputElement
  const file = input.files?.[0]
  input.value = ''
  if (!file) return

  setAiImageFile(file)
  // Also set as pending image for auto-attach
  setPendingImageFile(file)
  aiStatusMessage.value = null
  aiLoading.value = true

  try {
    const device = await api.parseDeviceFromImage(file)
    newDevice.value = {
      name: device.name || '',
      type: normalizeDeviceType(device.type),
    }
    newPorts.value = device.ports.map((port) => ({
      label: port.label,
      type: port.type,
      patchbayId: null,
    }))
    aiStatusMessage.value = t.devices.aiDraftReady
  } catch (err: any) {
    showError(err.message || strings.toast.imageParseFailed)
    console.error('Error parsing device image:', err)
  } finally {
    aiLoading.value = false
  }
}

const handleManualImageChange = (event: Event) => {
  const input = event.target as HTMLInputElement
  const file = input.files?.[0]
  input.value = ''
  if (!file) return
  
  setPendingImageFile(file)
}

const handleAddDevice = async () => {
  if (newPorts.value.length === 0) {
    showError(t.devices.validation.addPortFirst)
    return
  }
  if (!newDevice.value.name.trim()) {
    showError(t.devices.validation.nameRequired)
    return
  }

  isLoading.value = true

  try {
    const ports: DevicePort[] = newPorts.value.map((p) => ({
      id: p.id || '',
      label: p.label,
      type: p.type,
      patchbayId: p.patchbayId ?? null,
    }))

    let deviceId: number

    if (isEditing.value && editingDeviceId.value !== null) {
      const updated = await store.updateDevice(editingDeviceId.value, {
        name: newDevice.value.name,
        type: newDevice.value.type,
        ports,
      })
      deviceId = updated.id
      
      // Update selectedDevice reference
      if (selectedDevice.value?.id === deviceId) {
        selectedDevice.value = updated
      }
    } else {
      const created = await store.addDevice({
        name: newDevice.value.name,
        type: newDevice.value.type,
        ports,
      })
      deviceId = created.id
    }

    // Upload image if one is pending
    if (pendingImageFile.value) {
      try {
        isUploadingImage.value = true
        const updatedDevice = await store.uploadDeviceImage(deviceId, pendingImageFile.value)
        
        // Update selectedDevice reference if needed
        if (selectedDevice.value?.id === deviceId) {
          selectedDevice.value = updatedDevice
        }
      } catch (imgErr: any) {
        showError(`Device saved, but image upload failed: ${imgErr.message || 'Unknown error'}`)
        console.error('Error uploading device image:', imgErr)
      } finally {
        isUploadingImage.value = false
      }
    }

    store.pushToast({ type: 'success', message: strings.toast.deviceSaved })
    showAddModal.value = false
    editingDeviceId.value = null
    editSnapshot.value = null
    resetAddForm(true)
  } catch (err: any) {
    showError(err.message || strings.toast.deviceSaveFailed)
    console.error('Error saving device:', err)
  } finally {
    isLoading.value = false
  }
}

const requestDeleteDevice = (device: Device) => {
  deleteTarget.value = device
}

const confirmDeleteDevice = async () => {
  if (!deleteTarget.value) return
  isLoading.value = true
  try {
    await store.deleteDevice(deleteTarget.value.id)
    store.pushToast({ type: 'success', message: strings.toast.deviceDeleted })
    if (selectedDevice.value?.id === deleteTarget.value.id) {
      closeDetail()
    }
  } catch (err: any) {
    showError(err.message || strings.toast.deviceDeleteFailed)
    console.error('Error deleting device:', err)
  } finally {
    isLoading.value = false
    deleteTarget.value = null
  }
}

const cancelDeleteDevice = () => {
  deleteTarget.value = null
}

const handleLinkPort = (port: DevicePort) => {
  if (!selectedDevice.value) return
  store.startLinkingPort({
    portId: port.id,
    deviceId: selectedDevice.value.id,
    deviceName: selectedDevice.value.name,
    portLabel: port.label,
  }, {
    returnTab: 'devices',
    returnPayload: {
      resume: 'devices',
      deviceId: selectedDevice.value.id,
      portId: port.id,
      reopenDeviceDetail: true,
    },
  })
}

const handleUnlinkPort = async (port: DevicePort) => {
  if (!selectedDevice.value) return
  try {
    await store.unlinkPort(selectedDevice.value.id, port.id)
  } catch (err: any) {
    showError(err.message || strings.toast.unlinkFailed)
    console.error('Error unlinking port:', err)
  }
}

const handleGoToPatchbay = (port: DevicePort) => {
  if (!port.patchbayId) return
  store.highlightedPatchIds = [port.patchbayId]
  store.patchbayFocusId = port.patchbayId
  store.setTab('patchbay')
}

watch([newDevice, newPorts], () => {
  if (showAddModal.value && !isEditing.value) {
    saveDraft()
  }
}, { deep: true })

watch(() => store.activeTab, (tab) => {
  if (tab !== 'devices') return
  const payload = store.lastLinkReturnPayload as { resume?: string; deviceId?: number; reopenDeviceDetail?: boolean } | null
  if (!payload || payload.resume !== 'devices' || !payload.reopenDeviceDetail) return
  const deviceId = payload.deviceId
  if (!deviceId) return
  const device = store.devices.find(item => item.id === deviceId)
  if (device) {
    selectedDevice.value = device
  }
  store.clearLinkReturnPayload()
})

onBeforeUnmount(() => {
  window.removeEventListener('resize', updateViewport)
  if (aiPreviewUrl.value) {
    URL.revokeObjectURL(aiPreviewUrl.value)
  }
  if (pendingImagePreviewUrl.value) {
    URL.revokeObjectURL(pendingImagePreviewUrl.value)
  }
})
</script>

<template>
  <div class="devices-container">
    <div class="header">
      <div class="title-block">
        <h2>{{ t.devices.title }}</h2>
        <span v-if="isLoading" class="status-pill">{{ t.devices.saving }}</span>
      </div>
      <div class="header-actions">
        <input
          v-model="searchQuery"
          :placeholder="t.devices.searchPlaceholder"
          class="search-input"
        />
        <button class="add-btn" @click="openAddModal">{{ t.devices.addDevice }}</button>
      </div>
    </div>

    <div class="devices-layout">
      <div class="devices-list">
        <div
          v-for="device in filteredDevices"
          :key="device.id"
          class="device-card"
          :class="{ active: selectedDevice?.id === device.id }"
          @click="selectDevice(device)"
        >
          <div v-if="device.imageUrl" class="device-thumbnail">
            <img :src="getDeviceImageSrc(device) || ''" :alt="device.name" />
          </div>
          <div v-else class="device-thumbnail-placeholder">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor">
              <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
              <circle cx="8.5" cy="8.5" r="1.5"></circle>
              <polyline points="21 15 16 10 5 21"></polyline>
            </svg>
          </div>
          <div class="device-header">
            <h3>{{ device.name }}</h3>
            <div class="device-meta">
              <span class="device-type">{{ device.type }}</span>
              <button class="edit-btn" @click.stop="openEditModal(device)" :aria-label="t.devices.editDevice">
                <svg viewBox="0 0 24 24" aria-hidden="true">
                  <path d="M4 16.25V20h3.75L19.81 7.94l-3.75-3.75L4 16.25zm14.71-9.46a1 1 0 0 0 0-1.41l-1.09-1.09a1 1 0 0 0-1.41 0l-1.13 1.13 3.75 3.75 1.88-1.88z"/>
                </svg>
              </button>
            </div>
          </div>
          <div class="device-info">
            <span>{{ t.devices.portsCount(device.ports.length) }}</span>
          </div>
        </div>
      </div>

      <div v-if="selectedDevice && isDesktop" class="device-detail-panel">
        <div class="panel-header">
          <div class="panel-title">
            <h3>{{ selectedDevice.name }}</h3>
            <span class="device-type">{{ selectedDevice.type }}</span>
          </div>
          <div class="panel-actions">
            <button class="ghost-btn" @click="openEditModal(selectedDevice)">{{ t.devices.editDevice }}</button>
            <button class="ghost-btn" @click="closeDetail">{{ t.devices.closeDetail }}</button>
          </div>
        </div>

        <div class="device-details">
          <div v-if="selectedDevice.imageUrl" class="device-detail-image">
            <img :src="getDeviceImageSrc(selectedDevice) || ''" :alt="selectedDevice.name" />
          </div>
          
          <p><strong>{{ t.devices.typeLabel }}:</strong> {{ selectedDevice.type }}</p>
          <p><strong>{{ t.devices.idLabel }}:</strong> {{ selectedDevice.id }}</p>

          <h4>{{ t.devices.portsConfig }}</h4>
          <div class="ports-list">
            <div v-for="port in selectedDevice.ports" :key="port.id" class="port-item">
              <div class="port-info">
                <span class="port-label">{{ port.label }}</span>
                <span class="port-type">{{ t.devices.portTypes[port.type] }}</span>
              </div>

              <div class="port-actions">
                <span v-if="port.patchbayId" class="port-connection">
                  {{ t.devices.linkedTo(port.patchbayId) }}
                  <button class="link-action-btn unlink" @click.stop="handleUnlinkPort(port)">{{ t.devices.unlink }}</button>
                  <button class="link-action-btn ghost" @click.stop="handleGoToPatchbay(port)">
                    {{ t.devices.goToPatch(port.patchbayId) }}
                  </button>
                </span>
                <span v-else class="port-connection empty">
                  {{ t.devices.notConnected }}
                  <button class="link-action-btn link" @click.stop="handleLinkPort(port)">{{ t.devices.link }}</button>
                </span>
              </div>
            </div>
          </div>
        </div>

        <div class="panel-footer">
          <button class="delete-btn" @click="requestDeleteDevice(selectedDevice)">{{ t.devices.deleteDevice }}</button>
        </div>
      </div>
    </div>

    <div v-if="selectedDevice && !isDesktop" class="modal-overlay" @click="closeDetail">
      <div class="modal-content" @click.stop>
        <div class="modal-header">
          <h2>{{ selectedDevice.name }}</h2>
          <button class="close-btn" @click="closeDetail">{{ t.app.closeSymbol }}</button>
        </div>

        <div class="device-details">
          <div v-if="selectedDevice.imageUrl" class="device-detail-image">
            <img :src="getDeviceImageSrc(selectedDevice) || ''" :alt="selectedDevice.name" />
          </div>
          
          <p><strong>{{ t.devices.typeLabel }}:</strong> {{ selectedDevice.type }}</p>
          <p><strong>{{ t.devices.idLabel }}:</strong> {{ selectedDevice.id }}</p>

          <h3>{{ t.devices.portsConfig }}</h3>
          <div class="ports-list">
            <div v-for="port in selectedDevice.ports" :key="port.id" class="port-item">
              <div class="port-info">
                <span class="port-label">{{ port.label }}</span>
                <span class="port-type">{{ t.devices.portTypes[port.type] }}</span>
              </div>

              <div class="port-actions">
                <span v-if="port.patchbayId" class="port-connection">
                  {{ t.devices.linkedTo(port.patchbayId) }}
                  <button class="link-action-btn unlink" @click.stop="handleUnlinkPort(port)">{{ t.devices.unlink }}</button>
                  <button class="link-action-btn ghost" @click.stop="handleGoToPatchbay(port)">
                    {{ t.devices.goToPatch(port.patchbayId) }}
                  </button>
                </span>
                <span v-else class="port-connection empty">
                  {{ t.devices.notConnected }}
                  <button class="link-action-btn link" @click.stop="handleLinkPort(port)">{{ t.devices.link }}</button>
                </span>
              </div>
            </div>
          </div>
        </div>

        <div class="modal-actions">
          <button class="delete-btn" @click="requestDeleteDevice(selectedDevice)">{{ t.devices.deleteDevice }}</button>
        </div>
      </div>
    </div>

    <div v-if="showAddModal" class="modal-overlay" @click="closeAddModal">
      <div class="modal-content small add-device-modal" @click.stop>
        <div class="modal-header">
          <h2>{{ isEditing ? t.devices.editDevice : t.devices.addNewDevice }}</h2>
          <button class="close-btn" @click="closeAddModal">{{ t.app.closeSymbol }}</button>
        </div>
        <div class="add-device-tabs">
          <button
            class="tab-btn"
            :class="{ active: addDeviceMode === 'manual' }"
            @click="addDeviceMode = 'manual'"
          >
            {{ t.devices.tabManual }}
          </button>
          <button
            class="tab-btn"
            :class="{ active: addDeviceMode === 'ai' }"
            @click="addDeviceMode = 'ai'"
          >
            {{ t.devices.tabAutoDetect }}
          </button>
        </div>
        <div class="form-content">
          <div v-if="addDeviceMode === 'manual'" class="manual-form">
            <div class="form-group">
              <label>{{ t.devices.nameLabel }}</label>
              <input v-model="newDevice.name" :placeholder="t.devices.namePlaceholder" />
            </div>
            <div class="form-group">
              <label>{{ t.devices.typeLabel }}</label>
              <select v-model="newDevice.type">
                <option v-for="option in deviceTypeOptions" :key="option" :value="option">
                  {{ option }}
                </option>
              </select>
            </div>
            <div class="form-group">
              <label>Device Image (optional)</label>
              <p class="help-text">Maximum 12MB. Supported formats: JPG, PNG, WebP</p>
              <label class="ai-upload-btn">
                {{ pendingImagePreviewUrl || (isEditing && selectedDevice?.imageUrl) ? 'Change Image' : 'Upload Image' }}
                <input 
                  type="file" 
                  accept="image/*" 
                  @change="handleManualImageChange"
                  class="ai-file-input"
                />
              </label>
              <div v-if="pendingImageError" class="error-text">{{ pendingImageError }}</div>
              <div v-if="pendingImagePreviewUrl" class="ai-preview">
                <img :src="pendingImagePreviewUrl" alt="Preview" />
              </div>
              <div v-else-if="isEditing && selectedDevice?.imageUrl && !pendingImageFile" class="ai-preview">
                <img :src="getDeviceImageSrc(selectedDevice) || ''" :alt="selectedDevice.name" />
              </div>
              <button v-if="pendingImagePreviewUrl" class="ghost-btn" @click="clearPendingImage" type="button" style="margin-top: 8px;">Remove Image</button>
            </div>
            <div class="form-group ports-section">
              <div class="ports-header">
                <label>{{ t.devices.portsLabel }}</label>
                <button class="add-port-btn" @click="addPort">{{ t.devices.addPort }}</button>
              </div>
              <div class="ports-editor">
                <div v-for="(port, index) in newPorts" :key="index" class="port-edit-row">
                  <input v-model="port.label" :placeholder="t.devices.portNamePlaceholder" class="port-name-input" />
                  <select v-model="port.type" class="port-type-select">
                    <option v-for="option in portTypeOptions" :key="option" :value="option">
                      {{ t.devices.portTypes[option] }}
                    </option>
                  </select>
                  <button class="remove-port-btn" @click="removePort(index)">{{ t.devices.removePort }}</button>
                </div>
                <div v-if="newPorts.length === 0" class="ports-empty">
                  {{ t.devices.noPorts }}
                </div>
              </div>
            </div>
          </div>

          <div v-else class="ai-form">
            <div class="ai-stepper">
              <span :class="{ active: aiStep === 'upload' }">{{ t.devices.aiSteps.upload }}</span>
              <span :class="{ active: aiStep === 'processing' }">{{ t.devices.aiSteps.processing }}</span>
              <span :class="{ active: aiStep === 'review' }">{{ t.devices.aiSteps.review }}</span>
            </div>
            <p class="ai-help">{{ t.devices.aiHelp }}</p>
            <label class="ai-upload-btn">
              {{ t.devices.aiUpload }}
              <input
                class="ai-file-input"
                type="file"
                accept="image/*"
                capture="environment"
                @change="handleAiFileChange"
              />
            </label>
            <div v-if="aiPreviewUrl" class="ai-preview">
              <img :src="aiPreviewUrl" alt="Device preview" />
              <p class="help-text">This image will be attached to the device when you save.</p>
            </div>
            <div v-if="aiLoading" class="ai-progress">
              <span class="spinner"></span>
              <span>{{ t.devices.aiProcessing }}</span>
            </div>
            <div v-if="aiStatusMessage" class="ai-status">
              {{ aiStatusMessage }}
              <button class="ghost-btn" @click="addDeviceMode = 'manual'">
                {{ t.devices.aiReviewDraft }}
              </button>
            </div>
          </div>
        </div>
        <div class="form-footer">
          <button class="reset-btn" @click="handleResetForm" type="button">{{ t.devices.resetForm }}</button>
          <button 
            class="save-btn" 
            @click="handleAddDevice" 
            :disabled="!newDevice.name || newPorts.length === 0 || isUploadingImage"
          >
            <span v-if="isUploadingImage">Uploading image...</span>
            <span v-else>{{ isEditing ? t.devices.updateDevice : t.devices.createDevice }}</span>
          </button>
        </div>
      </div>
    </div>

    <ConfirmDialog
      v-if="deleteTarget"
      :title="t.confirm.deleteDeviceTitle"
      :message="t.confirm.deleteDeviceMessage(deleteTarget.name)"
      @confirm="confirmDeleteDevice"
      @cancel="cancelDeleteDevice"
    />
  </div>
</template>

<style scoped>
.devices-container {
  padding: var(--space-5);
  color: var(--text-primary);
  height: 100%;
  overflow: auto;
  background: var(--surface-1);
  border-radius: var(--radius-3);
  border: 1px solid var(--border-default);
  box-shadow: var(--shadow-1);
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--space-4);
  flex-wrap: wrap;
  gap: var(--space-3);
}

.title-block {
  display: flex;
  align-items: center;
  gap: var(--space-2);
}

.status-pill {
  padding: 4px 10px;
  border-radius: var(--radius-round);
  background: rgba(212, 154, 79, 0.2);
  border: 1px solid rgba(212, 154, 79, 0.5);
  color: var(--warning);
  font-size: 0.8rem;
}

.header-actions {
  display: flex;
  gap: var(--space-2);
  align-items: center;
}

.search-input {
  padding: 8px 12px;
  background-color: var(--surface-2);
  border: 1px solid var(--border-default);
  color: var(--text-primary);
  border-radius: var(--radius-2);
  min-width: 220px;
}

.add-btn {
  background-color: var(--accent);
  color: #0f120e;
  border: none;
  padding: 8px 16px;
  border-radius: var(--radius-2);
  cursor: pointer;
  font-weight: 600;
}

.devices-layout {
  display: grid;
  grid-template-columns: minmax(280px, 360px) 1fr;
  gap: var(--space-4);
}

.devices-list {
  display: flex;
  flex-direction: column;
  gap: var(--space-3);
}

.device-card {
  background-color: var(--surface-2);
  border: 1px solid var(--border-default);
  border-radius: var(--radius-3);
  padding: var(--space-3);
  cursor: pointer;
  transition: transform 0.2s, box-shadow 0.2s, border-color 0.2s;
}

.device-card:hover {
  transform: translateY(-2px);
  box-shadow: var(--shadow-1);
}

.device-card.active {
  border-color: rgba(61, 122, 88, 0.6);
}

.device-header {
  display: flex;
  justify-content: space-between;
  align-items: start;
  margin-bottom: var(--space-2);
}

.device-header h3 {
  margin: 0;
  font-size: 1.1rem;
  color: var(--text-primary);
}

.device-type {
  font-size: 0.8rem;
  background-color: var(--surface-3);
  padding: 2px 8px;
  border-radius: var(--radius-2);
  color: var(--text-secondary);
}

.device-meta {
  display: inline-flex;
  align-items: center;
  gap: var(--space-2);
}

.edit-btn {
  width: 28px;
  height: 28px;
  border-radius: var(--radius-2);
  border: 1px solid var(--border-default);
  background-color: var(--surface-1);
  color: var(--text-secondary);
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

.edit-btn svg {
  width: 16px;
  height: 16px;
  fill: currentColor;
}

.edit-btn:hover {
  border-color: var(--accent);
  color: var(--text-primary);
}

.device-info {
  font-size: 0.9rem;
  color: var(--text-secondary);
}

.device-detail-panel {
  background: var(--surface-2);
  border: 1px solid var(--border-default);
  border-radius: var(--radius-3);
  padding: var(--space-4);
  display: flex;
  flex-direction: column;
  gap: var(--space-4);
  min-height: 360px;
}

.panel-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: var(--space-2);
}

.panel-title h3 {
  margin: 0 0 4px;
}

.panel-actions {
  display: flex;
  gap: var(--space-2);
}

.device-details h4 {
  margin-top: var(--space-4);
}

.ports-list {
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
  margin-top: var(--space-2);
}

.port-item {
  background-color: var(--surface-1);
  padding: var(--space-2) var(--space-3);
  border-radius: var(--radius-2);
  display: flex;
  justify-content: space-between;
  align-items: center;
  border: 1px solid var(--border-default);
}

.port-info {
  display: flex;
  align-items: center;
  gap: var(--space-2);
}

.port-label {
  font-weight: 600;
  color: var(--text-primary);
}

.port-type {
  font-size: 0.75rem;
  padding: 2px 6px;
  border-radius: var(--radius-1);
  text-transform: uppercase;
  background: var(--surface-3);
  color: var(--text-muted);
}

.port-actions {
  display: flex;
  align-items: center;
}

.port-connection {
  font-size: 0.85rem;
  color: var(--text-secondary);
  display: flex;
  align-items: center;
  gap: var(--space-2);
}

.port-connection.empty {
  color: var(--text-muted);
  font-style: italic;
}

.link-action-btn {
  padding: 4px 8px;
  border-radius: var(--radius-1);
  border: none;
  cursor: pointer;
  font-size: 0.8rem;
  font-weight: 600;
}

.link-action-btn.link {
  background-color: var(--accent);
  color: #0f120e;
}

.link-action-btn.unlink {
  background-color: var(--danger);
  color: #fef7ee;
}

.link-action-btn.ghost {
  background: transparent;
  border: 1px solid var(--border-default);
  color: var(--text-secondary);
}

.panel-footer {
  display: flex;
  justify-content: flex-end;
}

.delete-btn {
  background-color: var(--danger);
  color: #fef7ee;
  border: none;
  padding: 8px 16px;
  border-radius: var(--radius-2);
  cursor: pointer;
}

.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(7, 6, 5, 0.7);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.modal-content {
  background-color: var(--surface-2);
  width: 90%;
  max-width: 600px;
  max-height: 80vh;
  border-radius: var(--radius-3);
  display: flex;
  flex-direction: column;
  box-shadow: var(--shadow-2);
  border: 1px solid var(--border-default);
}

.modal-content.small {
  max-width: 420px;
}

.modal-content.add-device-modal {
  max-height: 80vh;
  display: flex;
  flex-direction: column;
  max-width: 520px;
}

.modal-content.add-device-modal .form-content {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  min-height: 0;
}

.manual-form,
.ai-form {
  padding: var(--space-4);
}

.add-device-tabs {
  display: flex;
  gap: var(--space-2);
  padding: var(--space-2) var(--space-4);
  border-bottom: 1px solid var(--border-default);
  background-color: var(--surface-2);
}

.tab-btn {
  flex: 1;
  padding: 8px 10px;
  border-radius: var(--radius-2);
  border: 1px solid var(--border-default);
  background-color: var(--surface-1);
  color: var(--text-secondary);
  font-weight: 600;
  cursor: pointer;
}

.tab-btn.active {
  background-color: var(--accent);
  color: #0f120e;
  border-color: var(--accent);
}

.form-footer {
  padding: var(--space-3) var(--space-4);
  border-top: 1px solid var(--border-default);
  background-color: var(--surface-2);
  display: flex;
  gap: var(--space-2);
}

.form-footer .save-btn {
  flex: 1;
  margin-top: 0;
}

.reset-btn {
  background-color: var(--surface-3);
  color: var(--text-primary);
  border: 1px solid var(--border-default);
  padding: 10px;
  border-radius: var(--radius-2);
  cursor: pointer;
  font-weight: 600;
  flex: 1;
}

.modal-header {
  padding: var(--space-4);
  border-bottom: 1px solid var(--border-default);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.modal-header h2 {
  margin: 0;
  color: var(--text-primary);
}

.close-btn {
  background: none;
  border: none;
  color: var(--text-secondary);
  font-size: 1.5rem;
  cursor: pointer;
}

.device-details {
  padding: var(--space-4);
  overflow-y: auto;
}

.modal-actions {
  padding: var(--space-4);
  border-top: 1px solid var(--border-default);
  display: flex;
  justify-content: flex-end;
  gap: var(--space-2);
}

.form-content {
  padding: var(--space-4);
  display: flex;
  flex-direction: column;
  gap: var(--space-3);
}

.form-group {
  display: flex;
  flex-direction: column;
  gap: 5px;
}

.form-group label {
  color: var(--text-secondary);
  font-size: 0.9rem;
}

.form-group input,
.form-group select {
  padding: 8px;
  background-color: var(--surface-1);
  border: 1px solid var(--border-default);
  border-radius: var(--radius-2);
  color: var(--text-primary);
}

.ai-form {
  display: flex;
  flex-direction: column;
  gap: var(--space-3);
}

.ai-stepper {
  display: flex;
  gap: var(--space-2);
  font-size: 0.8rem;
  text-transform: uppercase;
  letter-spacing: 0.12em;
  color: var(--text-muted);
}

.ai-stepper span.active {
  color: var(--accent-2);
}

.ai-help {
  color: var(--text-secondary);
  font-size: 0.9rem;
}

.ai-upload-btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 10px 12px;
  border-radius: var(--radius-2);
  border: 1px dashed var(--border-default);
  background-color: var(--surface-1);
  color: var(--text-primary);
  cursor: pointer;
  font-weight: 600;
}

.ai-file-input {
  display: none;
}

.ai-preview {
  border-radius: var(--radius-2);
  border: 1px solid var(--border-default);
  overflow: hidden;
  max-height: 200px;
}

.ai-preview img {
  width: 100%;
  height: auto;
  display: block;
  object-fit: cover;
}

.ai-progress {
  display: flex;
  align-items: center;
  gap: var(--space-2);
  color: var(--text-secondary);
}

.spinner {
  width: 16px;
  height: 16px;
  border: 2px solid var(--border-default);
  border-top-color: var(--accent);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

.ai-status {
  color: var(--accent-2);
  font-size: 0.9rem;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: var(--space-2);
}

.save-btn {
  background-color: var(--accent);
  color: #0f120e;
  border: none;
  padding: 10px;
  border-radius: var(--radius-2);
  cursor: pointer;
  font-weight: 600;
  margin-top: 10px;
}

.save-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.ports-editor {
  display: flex;
  flex-direction: column;
  gap: var(--space-2);
  max-height: 200px;
  overflow-y: auto;
  padding-right: 4px;
}

.ports-section {
  flex: 1;
  min-height: 0;
  display: flex;
  flex-direction: column;
}

.ports-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}

.ports-header .add-port-btn {
  margin: 0;
  padding: 4px 10px;
  font-size: 0.85rem;
}

.ports-empty {
  color: var(--text-muted);
  font-style: italic;
  text-align: center;
  padding: var(--space-4);
  background-color: var(--surface-1);
  border-radius: var(--radius-2);
  border: 1px dashed var(--border-default);
}

.port-edit-row {
  display: flex;
  gap: var(--space-2);
  align-items: center;
}

.port-name-input {
  flex: 1;
  padding: 6px 8px;
  background-color: var(--surface-1);
  border: 1px solid var(--border-default);
  border-radius: var(--radius-2);
  color: var(--text-primary);
}

.port-type-select {
  padding: 6px 8px;
  background-color: var(--surface-1);
  border: 1px solid var(--border-default);
  border-radius: var(--radius-2);
  color: var(--text-primary);
  min-width: 90px;
}

.remove-port-btn {
  background-color: var(--danger);
  color: #fef7ee;
  border: none;
  padding: 6px 8px;
  border-radius: var(--radius-2);
  cursor: pointer;
  font-size: 0.8rem;
}

.add-port-btn {
  background-color: var(--surface-3);
  color: var(--text-primary);
  border: 1px dashed var(--border-default);
  padding: 8px;
  border-radius: var(--radius-2);
  cursor: pointer;
  margin-top: 4px;
}

.ghost-btn {
  background: transparent;
  border: 1px solid var(--border-default);
  color: var(--text-secondary);
  padding: 6px 12px;
  border-radius: var(--radius-2);
  cursor: pointer;
  font-weight: 600;
}

/* Device image styles */
.device-thumbnail {
  width: 100%;
  height: 100px;
  overflow: hidden;
  border-radius: var(--radius-2);
  margin-bottom: var(--space-2);
}

.device-thumbnail img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.device-thumbnail-placeholder {
  width: 100%;
  height: 100px;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: var(--surface-3);
  border-radius: var(--radius-2);
  margin-bottom: var(--space-2);
  color: var(--text-muted);
}

.device-thumbnail-placeholder svg {
  width: 32px;
  height: 32px;
  stroke-width: 1.5;
}

.device-detail-image {
  width: 100%;
  max-width: 400px;
  margin-bottom: var(--space-4);
  border-radius: var(--radius-2);
  overflow: hidden;
  border: 1px solid var(--border-default);
}

.device-detail-image img {
  width: 100%;
  height: auto;
  display: block;
}

.image-preview {
  margin-top: var(--space-2);
  border: 1px solid var(--border-default);
  border-radius: var(--radius-2);
  padding: var(--space-2);
  background-color: var(--surface-1);
}

.image-preview img {
  width: 100%;
  max-width: 300px;
  height: auto;
  display: block;
  margin-bottom: var(--space-2);
  border-radius: var(--radius-2);
}

.help-text {
  font-size: 0.85rem;
  color: var(--text-muted);
  margin-top: 4px;
  margin-bottom: 0;
}

.error-text {
  font-size: 0.85rem;
  color: var(--danger);
  margin-top: 4px;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

@media (max-width: 1024px) {
  .devices-layout {
    grid-template-columns: 1fr;
  }

  .device-detail-panel {
    display: none;
  }
}
</style>

================
File: src/App.vue
================
<script setup lang="ts">
import { computed, watchEffect } from 'vue'
import { SignedIn, SignedOut, UserButton, useAuth } from '@clerk/vue'
import { registerTokenGetter } from './lib/authToken'
import PatchBayGrid from './components/PatchBayGrid.vue'
import DevicesManager from './components/DevicesManager.vue'
import ConnectionFinder from './components/ConnectionFinder.vue'
import AuthScreen from './components/AuthScreen.vue'
import ToastHost from './ui/ToastHost.vue'
import { strings } from './ui/strings'
import { store } from './store'
import logoUrl from './assets/el-riche-mark.svg'

const t = strings
const { isLoaded, isSignedIn, getToken } = useAuth()

// Registrar la funci√≥n getToken para que api.ts pueda usarla
watchEffect(() => {
  if (isLoaded && isSignedIn && getToken) {
    // getToken es un ComputedRef, necesitamos extraer su funci√≥n
    const tokenFn = getToken.value
    if (tokenFn) {
      registerTokenGetter(tokenFn)
    }
  }
})

// Cargar datos cuando el usuario est√© autenticado y Clerk est√© listo
watchEffect(() => {
  if (isLoaded && isSignedIn && !store.hasLoadedInitialData && !store.loading) {
    store.loadData()
  }
})

const statusLabel = computed(() => {
  if (store.loading) return t.app.syncing
  if (store.error) return t.app.syncIssue
  return t.app.synced
})

const notifyComingSoon = () => {
  store.pushToast({ type: 'info', message: t.app.comingSoon })
}
</script>

<template>
  <!-- Loading state while Clerk initializes -->
  <div v-if="!isLoaded" class="auth-loading">
    <div class="loading-card">Cargando...</div>
  </div>

  <!-- Signed out: show login screen -->
  <SignedOut>
    <AuthScreen />
  </SignedOut>

  <!-- Signed in: show app -->
  <SignedIn>
    <div class="app-container">
      <div v-if="store.loading" class="loading-overlay">
        <div class="loading-card">{{ t.app.loadingData }}</div>
      </div>

      <header class="topbar">
        <div class="brand">
          <img class="brand-mark" :src="logoUrl" alt="" />
          <div class="brand-text">
            <span class="brand-title">{{ t.app.name }}</span>
            <span class="brand-subtitle">{{ t.app.tagline }}</span>
          </div>
        </div>

        <div class="topbar-center">
          <div class="status-chip" :class="{ loading: store.loading, error: store.error }">
            <span class="status-dot"></span>
            <span class="status-text">{{ statusLabel }}</span>
          </div>
          <div class="topbar-actions">
            <button class="ghost-btn" @click="notifyComingSoon">{{ t.app.export }}</button>
            <button class="ghost-btn" @click="notifyComingSoon">{{ t.app.help }}</button>
            <button class="ghost-btn" @click="notifyComingSoon">{{ t.app.shortcuts }}</button>
          </div>
        </div>

        <div class="topbar-right">
          <nav class="main-nav">
            <button
              :class="{ active: store.activeTab === 'patchbay' }"
              @click="store.setTab('patchbay')"
            >
              {{ t.nav.patchbay }}
            </button>
            <button
              :class="{ active: store.activeTab === 'devices' }"
              @click="store.setTab('devices')"
            >
              {{ t.nav.devices }}
            </button>
            <button
              :class="{ active: store.activeTab === 'connections' }"
              @click="store.setTab('connections')"
            >
              {{ t.nav.connections }}
            </button>
          </nav>
          <div class="user-menu">
            <UserButton />
          </div>
        </div>
      </header>

      <main class="content-area">
        <PatchBayGrid v-if="store.activeTab === 'patchbay'" />
        <DevicesManager v-if="store.activeTab === 'devices'" />
        <ConnectionFinder v-if="store.activeTab === 'connections'" />
      </main>

      <ToastHost />
    </div>
  </SignedIn>
</template>

<style scoped>
.auth-loading {
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 100vh;
  background: linear-gradient(135deg, #1a1a2e 0%, #0f0f1e 100%);
}

.app-container {
  display: flex;
  flex-direction: column;
  height: 100vh;
  animation: fade-in 0.6s ease-out;
}

.topbar {
  display: grid;
  grid-template-columns: auto 1fr auto;
  gap: var(--space-4);
  align-items: center;
  padding: var(--space-3) var(--space-5);
  background: rgba(26, 23, 19, 0.94);
  border-bottom: 1px solid var(--border-default);
  backdrop-filter: blur(14px);
}

.topbar-right {
  display: flex;
  align-items: center;
  gap: var(--space-4);
}

.user-menu {
  display: flex;
  align-items: center;
}

.brand {
  display: flex;
  align-items: center;
  gap: var(--space-3);
}

.brand-mark {
  width: 44px;
  height: 44px;
}

.brand-text {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.brand-title {
  font-family: var(--font-display);
  font-size: 1.4rem;
  letter-spacing: 0.04em;
}

.brand-subtitle {
  font-size: 0.85rem;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 0.18em;
}

.topbar-center {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: var(--space-4);
  flex-wrap: wrap;
}

.status-chip {
  display: inline-flex;
  align-items: center;
  gap: var(--space-2);
  padding: 6px 12px;
  border-radius: var(--radius-round);
  border: 1px solid var(--border-default);
  color: var(--text-secondary);
  background: var(--surface-1);
}

.status-chip.loading {
  border-color: rgba(212, 154, 79, 0.6);
  color: var(--warning);
}

.status-chip.error {
  border-color: rgba(176, 75, 61, 0.7);
  color: var(--danger);
}

.status-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: var(--accent-2);
}

.status-chip.loading .status-dot {
  background: var(--warning);
}

.status-chip.error .status-dot {
  background: var(--danger);
}

.topbar-actions {
  display: flex;
  gap: var(--space-2);
}

.ghost-btn {
  background: transparent;
  border: 1px solid var(--border-default);
  color: var(--text-secondary);
  padding: 6px 12px;
  border-radius: var(--radius-2);
  cursor: pointer;
  font-weight: 600;
  transition: border-color 0.2s ease, color 0.2s ease;
}

.ghost-btn:hover {
  border-color: var(--accent);
  color: var(--text-primary);
}

.main-nav {
  display: flex;
  gap: var(--space-2);
  background: var(--surface-2);
  padding: var(--space-1);
  border-radius: var(--radius-round);
  border: 1px solid var(--border-default);
}

.main-nav button {
  background-color: transparent;
  border: none;
  color: var(--text-secondary);
  padding: 8px 16px;
  cursor: pointer;
  font-size: 0.95rem;
  font-weight: 600;
  border-radius: var(--radius-round);
  transition: all 0.2s;
}

.main-nav button:hover {
  color: var(--text-primary);
  background-color: var(--surface-3);
}

.main-nav button.active {
  color: #11130f;
  background-color: var(--accent);
}

.content-area {
  flex: 1;
  overflow: hidden;
  position: relative;
  padding: var(--space-5);
}

.loading-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(8, 7, 6, 0.65);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2000;
}

.loading-card {
  background: var(--surface-2);
  padding: var(--space-4) var(--space-5);
  border-radius: var(--radius-3);
  border: 1px solid var(--border-default);
  color: var(--text-primary);
  box-shadow: var(--shadow-1);
}

@media (max-width: 960px) {
  .topbar {
    grid-template-columns: 1fr;
    justify-items: stretch;
  }

  .topbar-center {
    justify-content: space-between;
  }

  .topbar-right {
    flex-direction: column;
    align-items: stretch;
    gap: var(--space-3);
  }

  .main-nav {
    justify-content: space-between;
  }

  .user-menu {
    justify-content: center;
  }
}
</style>

================
File: src/store/index.ts
================
import { reactive } from 'vue'
import { api, type ApiPort, type ApiDevice, type ApiPatchbayPoint } from '@/lib/api'
import { strings } from '@/ui/strings'

// Types
export interface PatchBayNode {
  id: number;
  name: string;
  description: string;
  type: string;
}

export interface DevicePort {
  id: string;
  label: string;
  type: 'Input' | 'Output' | 'Other';
  patchbayId: number | null;
}

export interface Device {
  id: number;
  name: string;
  type: string;
  ports: DevicePort[];
  imageUrl?: string | null;
  imageUpdatedAt?: string | null;
}

interface PendingLink {
  portId: string;
  deviceId: number;
  deviceName: string;
  portLabel: string;
}

interface LinkFlow {
  returnTab: 'devices' | 'connections' | 'patchbay';
  returnPayload?: Record<string, unknown>;
}

export interface Toast {
  id: string;
  type: 'success' | 'error' | 'info';
  message: string;
}

// Convert API types (snake_case) to frontend types (camelCase)
function apiPortToDevicePort(apiPort: ApiPort): DevicePort {
  return {
    id: apiPort.id,
    label: apiPort.label,
    type: apiPort.type,
    patchbayId: apiPort.patchbay_id,
  }
}

function apiDeviceToDevice(apiDevice: ApiDevice): Device {
  return {
    id: apiDevice.id,
    name: apiDevice.name,
    type: apiDevice.type,
    ports: apiDevice.ports.map(apiPortToDevicePort),
    imageUrl: apiDevice.image_url,
    imageUpdatedAt: apiDevice.image_updated_at,
  }
}

function apiPatchbayToNode(apiPoint: ApiPatchbayPoint): PatchBayNode {
  return {
    id: apiPoint.id,
    name: apiPoint.name,
    description: apiPoint.description,
    type: apiPoint.type,
  }
}

export const store = reactive({
  patchbayNodes: [] as PatchBayNode[],
  devices: [] as Device[],
  selectedDevice: null as Device | null,
  loading: false,
  error: null as string | null,
  hasLoadedInitialData: false, // Flag to prevent multiple loads
  activeTab: 'devices', // 'patchbay' | 'devices' | 'connections'
  selectionMode: false,
  pendingLink: null as PendingLink | null, // The port waiting to be linked (from Device -> Patchbay flow)
  linkFlow: null as LinkFlow | null,
  lastLinkReturnPayload: null as LinkFlow['returnPayload'] | null,
  highlightedPatchIds: [] as number[], // For connection finder highlighting
  patchbayFocusId: null as number | null,
  connectionFinderState: {
    a: null as null | { deviceId: number; portId: string },
    b: null as null | { deviceId: number; portId: string },
  },
  toasts: [] as Toast[],
  
  // Load data from API
  async loadData() {
    this.loading = true
    this.error = null
    
    try {
      const state = await api.getState()
      this.patchbayNodes = state.patchbay_points.map(apiPatchbayToNode)
      this.devices = state.devices.map(apiDeviceToDevice)
      this.hasLoadedInitialData = true
    } catch (err: any) {
      // Handle auth-specific errors
      if (err.message === 'AUTH_EXPIRED') {
        this.error = strings.toast.sessionExpired || 'Sesi√≥n expirada. Por favor, volv√© a iniciar sesi√≥n.'
      } else if (err.message === 'AUTH_FORBIDDEN') {
        this.error = strings.toast.noPermission || 'No ten√©s permisos para acceder a estos datos.'
      } else {
        this.error = err.message || strings.toast.loadFailed
      }
      this.pushToast({ type: 'error', message: this.error || strings.toast.loadFailed })
      console.error('Error loading data:', err)
    } finally {
      this.loading = false
    }
  },
  
  // Actions
  setTab(tab: string) {
    this.activeTab = tab
  },
  
  // Flow: Device -> Patchbay (Select a slot for a specific port)
  startLinkingPort(payload: PendingLink, options?: Partial<LinkFlow>) {
    this.pendingLink = payload
    this.selectionMode = true
    this.activeTab = 'patchbay'
    this.linkFlow = {
      returnTab: options?.returnTab ?? 'devices',
      returnPayload: options?.returnPayload,
    }
  },
  
  async completeLink(patchbayId: number) {
    if (!this.pendingLink) return

    try {
      const response = await api.linkPort(this.pendingLink.portId, patchbayId)
      
      // Update local state: unlink old port if any
      if (response.unlinked_port_id) {
        for (const device of this.devices) {
          const oldPort = device.ports.find(p => p.id === response.unlinked_port_id)
          if (oldPort) {
            oldPort.patchbayId = null
            break
          }
        }
      }

      // Update linked port
      for (const device of this.devices) {
        const port = device.ports.find(p => p.id === this.pendingLink?.portId)
        if (port && response.patchbay_id !== null) {
          port.patchbayId = response.patchbay_id
          break
        }
      }
      this.pushToast({
        type: 'success',
        message: strings.toast.linkedSuccess(
          this.pendingLink.deviceName,
          this.pendingLink.portLabel,
          response.patchbay_id ?? 0
        ),
      })
    } catch (err: any) {
      console.error('Error linking port:', err)
      this.pushToast({ type: 'error', message: err.message || strings.toast.linkFailed })
      return
    }
    
    this.activeTab = this.linkFlow?.returnTab ?? 'devices'
    this.lastLinkReturnPayload = this.linkFlow?.returnPayload ?? null
    this.cancelLinking()
  },
  
  cancelLinking() {
    this.pendingLink = null
    this.selectionMode = false
    this.linkFlow = null
  },
  
  // Flow: Patchbay -> Device (Unlink or Link via Search)
  async unlinkPort(deviceId: number, portId: string) {
    try {
      await api.unlinkPort(portId)
      
      const device = this.devices.find(d => d.id === deviceId)
      if (device) {
        const port = device.ports.find(p => p.id === portId)
        if (port) port.patchbayId = null
      }
    } catch (err: any) {
      console.error('Error unlinking port:', err)
      this.pushToast({ type: 'error', message: err.message || strings.toast.unlinkFailed })
    }
  },

  // Link a specific port to a patchbay ID (used from the Patchbay search modal)
  async linkPatchbayToDevice(patchbayId: number, deviceId: number, portId: string) {
    try {
      const response = await api.linkPort(portId, patchbayId)
      
      // Update local state: unlink old port if any
      if (response.unlinked_port_id) {
        for (const device of this.devices) {
          const oldPort = device.ports.find(p => p.id === response.unlinked_port_id)
          if (oldPort) {
            oldPort.patchbayId = null
            break
          }
        }
      }

      // Update linked port
      const device = this.devices.find(d => d.id === deviceId)
      if (device) {
        const port = device.ports.find(p => p.id === portId)
        if (port && response.patchbay_id !== null) {
          port.patchbayId = response.patchbay_id
        }
      }
      return true
    } catch (err: any) {
      console.error('Error linking patchbay to device:', err)
      this.pushToast({ type: 'error', message: err.message || strings.toast.linkFailed })
      return false
    }
  },
  
  async addDevice(device: Omit<Device, 'id'>): Promise<Device> {
    try {
      const apiDevice = await api.createDevice({
        name: device.name,
        type: device.type,
        ports: device.ports.map(p => ({
          label: p.label,
          type: p.type,
          patchbay_id: p.patchbayId,
        })),
      })
      
      const newDevice = apiDeviceToDevice(apiDevice)
      this.devices.push(newDevice)
      return newDevice
    } catch (err: any) {
      console.error('Error adding device:', err)
      throw err
    }
  },

  async updateDevice(id: number, payload: { name: string; type: string; ports: DevicePort[] }): Promise<Device> {
    try {
      const apiDevice = await api.updateDevice(id, {
        name: payload.name,
        type: payload.type,
        ports: payload.ports.map(p => ({
          id: p.id || undefined,
          label: p.label,
          type: p.type,
          patchbay_id: p.patchbayId ?? null,
        })),
      })

      const updatedDevice = apiDeviceToDevice(apiDevice)
      const index = this.devices.findIndex(d => d.id === id)
      if (index !== -1) {
        this.devices[index] = updatedDevice
      }
      return updatedDevice
    } catch (err: any) {
      console.error('Error updating device:', err)
      throw err
    }
  },
  
  async deleteDevice(id: number) {
    try {
      await api.deleteDevice(id)
      
      const index = this.devices.findIndex(d => d.id === id)
      if (index !== -1) this.devices.splice(index, 1)
      
      // Clear selection if deleted device was selected
      if (this.selectedDevice?.id === id) {
        this.selectedDevice = null
      }
    } catch (err: any) {
      console.error('Error deleting device:', err)
      throw err
    }
  },

  async uploadDeviceImage(deviceId: number, image: File): Promise<Device> {
    try {
      const apiDevice = await api.uploadDeviceImage(deviceId, image)
      const updatedDevice = apiDeviceToDevice(apiDevice)
      
      // Replace device in store
      const index = this.devices.findIndex(d => d.id === deviceId)
      if (index !== -1) {
        this.devices[index] = updatedDevice
      }
      
      // Update selectedDevice reference if it's the same device
      if (this.selectedDevice?.id === deviceId) {
        this.selectedDevice = updatedDevice
      }
      
      return updatedDevice
    } catch (err: any) {
      console.error('Error uploading device image:', err)
      throw err
    }
  },

  setConnectionFinderSelection(side: 'a' | 'b', deviceId: number, portId: string) {
    this.connectionFinderState[side] = { deviceId, portId }
  },

  clearConnectionFinderSelection(side: 'a' | 'b') {
    this.connectionFinderState[side] = null
  },

  swapConnectionFinderSelections() {
    const temp = this.connectionFinderState.a
    this.connectionFinderState.a = this.connectionFinderState.b
    this.connectionFinderState.b = temp
  },

  clearLinkReturnPayload() {
    this.lastLinkReturnPayload = null
  },

  pushToast(payload: Omit<Toast, 'id'>) {
    const id = `${Date.now()}-${Math.random().toString(16).slice(2)}`
    const toast: Toast = { id, ...payload }
    this.toasts.push(toast)
    window.setTimeout(() => this.dismissToast(id), 4200)
  },

  dismissToast(id: string) {
    const index = this.toasts.findIndex(toast => toast.id === id)
    if (index !== -1) this.toasts.splice(index, 1)
  },
  
  // Helpers
  getDeviceByPatchbayId(patchbayId: number) {
    for (const device of this.devices) {
      const port = device.ports.find(p => p.patchbayId === patchbayId)
      if (port) return { device, port }
    }
    return null
  }
})

================
File: .github/workflows/main.yml
================
name: CD - Deploy

on:
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest

    env:
      REMOTE_PATH: ${{ secrets.REMOTE_PATH }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Preparar clave SSH
        run: |
          mkdir -p ~/.ssh
          echo "$PI_SSH_PRIVATE_KEY" > key.pem
          chmod 600 key.pem
        env:
          PI_SSH_PRIVATE_KEY: ${{ secrets.PI_SSH_PRIVATE_KEY }}

      - name: Pull y desplegar con Docker Compose en el VPS
        run: |
          ssh -o StrictHostKeyChecking=no -i key.pem -p "$PI_SSH_PORT" "$PI_USER@$PI_HOST" \
                "REMOTE_PATH='${REMOTE_PATH}' bash -s" <<'EOF'
          set -e
          echo "Conectado al VPS"
          cd "$REMOTE_PATH"
          echo "Directorio actual de trabajo: $(pwd)"

          echo "Haciendo git pull..."
          git pull origin main

          echo "Deteniendo contenedores..."
          docker compose down || true

          echo "Levantando con build..."
          docker compose up -d --build

          echo "Limpieza de im√°genes no utilizadas..."
          docker image prune -f || true

          echo "‚úÖ Despliegue completado."
          EOF

        env:
          PI_HOST: ${{ secrets.PI_HOST }}
          PI_USER: ${{ secrets.PI_USER }}
          PI_SSH_PORT: ${{ secrets.PI_SSH_PORT }}
          REMOTE_PATH: ${{ env.REMOTE_PATH }}

      - name: Limpiar clave local
        if: always()
        run: rm -f key.pem





================================================================
End of Codebase
================================================================
